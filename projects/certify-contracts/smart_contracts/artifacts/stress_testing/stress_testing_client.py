# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "create(address,address,uint64,uint64,uint64)uint64": {
            "call_config": {
                "no_op": "CREATE"
            }
        },
        "start(address,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void": {
            "structs": {
                "key_reg_info": {
                    "name": "KeyRegTxnInfo",
                    "elements": [
                        [
                            "vote_first",
                            "uint64"
                        ],
                        [
                            "vote_last",
                            "uint64"
                        ],
                        [
                            "vote_key_dilution",
                            "uint64"
                        ],
                        [
                            "vote_pk",
                            "byte[32]"
                        ],
                        [
                            "selection_pk",
                            "byte[32]"
                        ],
                        [
                            "state_proof_pk",
                            "byte[64]"
                        ],
                        [
                            "sender",
                            "address"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,address)": {
            "structs": {
                "output": {
                    "name": "ReturnStressTestingEnd",
                    "elements": [
                        [
                            "success",
                            "bool"
                        ],
                        [
                            "avr_online_stake",
                            "uint64"
                        ],
                        [
                            "cnt_produced_block",
                            "uint64"
                        ],
                        [
                            "round_start",
                            "uint64"
                        ],
                        [
                            "round_end",
                            "uint64"
                        ],
                        [
                            "round_ended",
                            "uint64"
                        ],
                        [
                            "stake",
                            "uint64"
                        ],
                        [
                            "user_address",
                            "address"
                        ]
                    ]
                }
            },
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "record()void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "unused()uint64": {
            "call_config": {
                "delete_application": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5hcHByb3ZhbF9wcm9ncmFtOgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2VudHJ5cG9pbnRAMgogICAgY2FsbHN1YiBfX2luaXRfXwoKbWFpbl9lbnRyeXBvaW50QDI6CiAgICBjYWxsc3ViIF9fcHV5YV9hcmM0X3JvdXRlcl9fCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5fX3B1eWFfYXJjNF9yb3V0ZXJfXygpIC0+IHVpbnQ2NDoKX19wdXlhX2FyYzRfcm91dGVyX186CiAgICBwcm90byAwIDEKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZnRlcl9pZl9lbHNlQDEwCiAgICBtZXRob2QgImNyZWF0ZShhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgbWV0aG9kICJzdGFydChhZGRyZXNzLCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSxwYXkpdm9pZCIKICAgIG1ldGhvZCAiZW5kKGFkZHJlc3MpKGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiCiAgICBtZXRob2QgInJlY29yZCgpdm9pZCIKICAgIG1ldGhvZCAidW51c2VkKCl1aW50NjQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19jcmVhdGVfcm91dGVAMiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19zdGFydF9yb3V0ZUAzIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2VuZF9yb3V0ZUA0IF9fcHV5YV9hcmM0X3JvdXRlcl9fX3JlY29yZF9yb3V0ZUA1IF9fcHV5YV9hcmM0X3JvdXRlcl9fX3VudXNlZF9yb3V0ZUA2CiAgICBpbnQgMAogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jcmVhdGVfcm91dGVAMjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgY2FsbHN1YiBjcmVhdGUKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX3N0YXJ0X3JvdXRlQDM6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIGNhbGxzdWIgc3RhcnQKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2VuZF9yb3V0ZUA0OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBEZWxldGVBcHBsaWNhdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGNhbGxzdWIgZW5kCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19yZWNvcmRfcm91dGVANToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmVjb3JkCiAgICBpbnQgMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX191bnVzZWRfcm91dGVANjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIHVudXNlZAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYWZ0ZXJfaWZfZWxzZUAxMDoKICAgIGludCAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5jcmVhdGUodXNlcl9hZGRyZXNzOiBieXRlcywgb3duZXJfYWRkcmVzczogYnl0ZXMsIHN0YWtlOiB1aW50NjQsIGR1cmF0aW9uOiB1aW50NjQsIGR1cmF0aW9uX21heDogdWludDY0KSAtPiBieXRlczoKY3JlYXRlOgogICAgcHJvdG8gNSAxCiAgICBieXRlICJ1c2VyX2FkZHJlc3MiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJvd25lcl9hZGRyZXNzIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2UiCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJkdXJhdGlvbiIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImR1cmF0aW9uX21heCIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInJvdW5kX2VuZGVkIgogICAgaW50IDEwMDAwMDAwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNudF9wcm9kdWNlZF9ibG9ja3MiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInRvdGFsX3N0YWtlX3N1bSIKICAgIGludCA0MjAwMDA0MgogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNudF90b3RhbF9zdGFrZV9zdW0iCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAicm91bmRfY3JlYXRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9jcmVhdGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2NyZWF0ZWQgZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAiZHVyYXRpb25fbWF4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmR1cmF0aW9uX21heCBleGlzdHMKICAgICsKICAgIGJ5dGUgInJvdW5kX2VuZF9tYXgiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgaW50IDAKICAgIGJ5dGUgImR1cmF0aW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmR1cmF0aW9uIGV4aXN0cwogICAgaW50IDAKICAgIGJ5dGUgImR1cmF0aW9uX21heCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kdXJhdGlvbl9tYXggZXhpc3RzCiAgICA8CiAgICBhc3NlcnQgLy8gTWF4aW11bSBlbmQgcm91bmQgbXVzdCBiZSBsYXJnZXIgdGhhbiByZXF1ZXN0ZWQgZHVyYXRpb24uCiAgICBpbnQgMAogICAgYnl0ZSAiZHVyYXRpb24iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZHVyYXRpb24gZXhpc3RzCiAgICBpbnQgMQogICAgPgogICAgYXNzZXJ0IC8vIER1cmF0aW9uIGlzIHRvbyBzaG9ydCBkdWUgdG8gY29uc2Vuc3VzIGRlbGF5LgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5zdGFydCh1c2VyX2FkZHJlc3M6IGJ5dGVzLCBrZXlfcmVnX2luZm86IGJ5dGVzLCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKc3RhcnQ6CiAgICBwcm90byAzIDAKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBDUkVBVEVELgogICAgaW50IDAKICAgIGJ5dGUgInVzZXJfYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi51c2VyX2FkZHJlc3MgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTMKICAgID09CiAgICBhc3NlcnQgLy8gVXNlciBkb2VzIG5vdCBtYXRjaCB0aGUgc3RyZXNzIHRlc3QgdXNlci4KICAgIGdsb2JhbCBSb3VuZAogICAgaW50IDAKICAgIGJ5dGUgImR1cmF0aW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmR1cmF0aW9uIGV4aXN0cwogICAgKwogICAgYnl0ZSAicm91bmRfZW5kIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZF9tYXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kX21heCBleGlzdHMKICAgIDwKICAgIGFzc2VydCAvLyBUZXN0IHdhcyBub3Qgc3RhcnRlZCBzb29uIGVub3VnaC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGludCAwCiAgICBieXRlICJzdGFrZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGFrZSBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBnbG9iYWwgUm91bmQKICAgIGludCAxCiAgICArCiAgICBieXRlICJyb3VuZF9zdGFydCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICBieXRlICJsYXN0X2Jsb2NrIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfY3JlYXRlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9jcmVhdGVkIGV4aXN0cwogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfZW5kX21heCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmRfbWF4IGV4aXN0cwogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAxNTIgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkdXAKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0CiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCA4OCA2NCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgU3RhdGVQcm9vZlBLCiAgICBpdHhuX2ZpZWxkIFZvdGVLZXlEaWx1dGlvbgogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFZvdGVMYXN0CiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgVm90ZUZpcnN0CiAgICBpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCiAgICBpdHhuX2ZpZWxkIFZvdGVQSwogICAgaW50IGtleXJlZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYnl0ZSAic3RhdGUiCiAgICBieXRlIDB4MDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5lbmQodXNlcl9hZGRyZXNzOiBieXRlcykgLT4gYnl0ZXM6CmVuZDoKICAgIHByb3RvIDEgMQogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICBieXRlICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGludCAwCiAgICBieXRlICJvd25lcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm93bmVyX2FkZHJlc3MgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBieiBlbmRfZWxzZV9ib2R5QDUKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmRlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmRlZCBleGlzdHMKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgPAogICAgYnogZW5kX2Vsc2VfYm9keUAzCiAgICBpbnQgMAogICAgYiBlbmRfYWZ0ZXJfaWZfZWxzZUA5CgplbmRfZWxzZV9ib2R5QDM6CiAgICBpbnQgMQogICAgYiBlbmRfYWZ0ZXJfaWZfZWxzZUA5CgplbmRfZWxzZV9ib2R5QDU6CiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfZW5kZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kZWQgZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIDwKICAgICEKICAgIGFzc2VydCAvLyBUaGlzIGFjY291bnQgaXMgbm90IGFsbG93ZWQgdG8gdGVybWluYXRlIHRoZSB0ZXN0LgogICAgaW50IDEKCmVuZF9hZnRlcl9pZl9lbHNlQDk6CiAgICBpdHhuX2JlZ2luCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIGR1cAogICAgaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGludCBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGludCAwCiAgICBieXRlICJ0b3RhbF9zdGFrZV9zdW0iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfc3Rha2Vfc3VtIGV4aXN0cwogICAgaW50IDAKICAgIGJ5dGUgImNudF90b3RhbF9zdGFrZV9zdW0iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X3RvdGFsX3N0YWtlX3N1bSBleGlzdHMKICAgIC8KICAgIGJ5dGUgMHgwMAogICAgaW50IDAKICAgIHVuY292ZXIgMwogICAgc2V0Yml0CiAgICBzd2FwCiAgICBpdG9iCiAgICBpbnQgMAogICAgYnl0ZSAiY250X3Byb2R1Y2VkX2Jsb2NrcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfcHJvZHVjZWRfYmxvY2tzIGV4aXN0cwogICAgaXRvYgogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX3N0YXJ0IGV4aXN0cwogICAgaXRvYgogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBpdG9iCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfZW5kZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kZWQgZXhpc3RzCiAgICBpdG9iCiAgICBpbnQgMAogICAgYnl0ZSAic3Rha2UiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2UgZXhpc3RzCiAgICBpdG9iCiAgICBpbnQgMAogICAgYnl0ZSAidXNlcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnVzZXJfYWRkcmVzcyBleGlzdHMKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA3CiAgICBjb25jYXQKICAgIHVuY292ZXIgNgogICAgY29uY2F0CiAgICB1bmNvdmVyIDUKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5yZWNvcmQoKSAtPiB2b2lkOgpyZWNvcmQ6CiAgICBwcm90byAwIDAKICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgZ2xvYmFsIFJvdW5kCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfZW5kZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kZWQgZXhpc3RzCiAgICA8CiAgICBhc3NlcnQKICAgIGdsb2JhbCBSb3VuZAogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBkaWcgMQogICAgPgogICAgYXNzZXJ0IC8vIEJsb2NrcyBwcm9kdWNlZCBhZnRlciB0ZXN0IGVuZCBzaG91bGRuJ3QgYmUgY291bnRlZC4KICAgIGludCAwCiAgICBieXRlICJsYXN0X2Jsb2NrIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmxhc3RfYmxvY2sgZXhpc3RzCiAgICBkaWcgMQogICAgPAogICAgYXNzZXJ0IC8vIFRoZXJlIGlzIG5vIG5ldyBwcm9kdWNlZCBibG9jayB0byByZWNvcmQuCiAgICBpbnQgMAogICAgYnl0ZSAiY250X3Byb2R1Y2VkX2Jsb2NrcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfcHJvZHVjZWRfYmxvY2tzIGV4aXN0cwogICAgaW50IDEKICAgICsKICAgIGJ5dGUgImNudF9wcm9kdWNlZF9ibG9ja3MiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAibGFzdF9ibG9jayIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBpbnQgMAogICAgYnl0ZSAidG90YWxfc3Rha2Vfc3VtIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX3N0YWtlX3N1bSBleGlzdHMKICAgIGludCA0MjAwMDA0MgogICAgKwogICAgYnl0ZSAidG90YWxfc3Rha2Vfc3VtIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGludCAwCiAgICBieXRlICJjbnRfdG90YWxfc3Rha2Vfc3VtIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF90b3RhbF9zdGFrZV9zdW0gZXhpc3RzCiAgICBpbnQgMQogICAgKwogICAgYnl0ZSAiY250X3RvdGFsX3N0YWtlX3N1bSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy51bnVzZWQoKSAtPiBieXRlczoKdW51c2VkOgogICAgcHJvdG8gMCAxCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDEKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gQ1JFQVRFRC4KICAgIGdsb2JhbCBSb3VuZAogICAgaW50IDAKICAgIGJ5dGUgImR1cmF0aW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmR1cmF0aW9uIGV4aXN0cwogICAgKwogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZF9tYXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kX21heCBleGlzdHMKICAgID4KICAgIGFzc2VydCAvLyBDYW5ub3QgY2xhaW0gdGhlIHRlc3QgYXMgdW51c2VkIGJlY2F1c2UgdGhlcmUgaXMgc3RpbGwgZW5vdWdoIHRpbWUgdG8gZmluaXNoIGl0LgogICAgaXR4bl9iZWdpbgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgaW50IDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpbnQgcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpbnQgMAogICAgYnl0ZSAic3Rha2UiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2UgZXhpc3RzCiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgcHJvdG8gMCAwCiAgICBieXRlICJ1c2VyX2FkZHJlc3MiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJvd25lcl9hZGRyZXNzIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2UiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImR1cmF0aW9uIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJkdXJhdGlvbl9tYXgiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInJvdW5kX2NyZWF0ZWQiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInJvdW5kX3N0YXJ0IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInJvdW5kX2VuZGVkIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJyb3VuZF9lbmRfbWF4IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJsYXN0X2Jsb2NrIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJjbnRfcHJvZHVjZWRfYmxvY2tzIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJ0b3RhbF9zdGFrZV9zdW0iCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNudF90b3RhbF9zdGFrZV9zdW0iCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuc3RyZXNzX3Rlc3RpbmcuY29udHJhY3QuU3RyZXNzVGVzdGluZy5jbGVhcl9zdGF0ZV9wcm9ncmFtOgogICAgaW50IDEKICAgIHJldHVybgo="
    },
    "state": {
        "global": {
            "num_byte_slices": 3,
            "num_uints": 12
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "cnt_produced_blocks": {
                    "type": "uint64",
                    "key": "cnt_produced_blocks"
                },
                "cnt_total_stake_sum": {
                    "type": "uint64",
                    "key": "cnt_total_stake_sum"
                },
                "duration": {
                    "type": "uint64",
                    "key": "duration"
                },
                "duration_max": {
                    "type": "uint64",
                    "key": "duration_max"
                },
                "last_block": {
                    "type": "uint64",
                    "key": "last_block"
                },
                "owner_address": {
                    "type": "bytes",
                    "key": "owner_address"
                },
                "round_created": {
                    "type": "uint64",
                    "key": "round_created"
                },
                "round_end": {
                    "type": "uint64",
                    "key": "round_end"
                },
                "round_end_max": {
                    "type": "uint64",
                    "key": "round_end_max"
                },
                "round_ended": {
                    "type": "uint64",
                    "key": "round_ended"
                },
                "round_start": {
                    "type": "uint64",
                    "key": "round_start"
                },
                "stake": {
                    "type": "uint64",
                    "key": "stake"
                },
                "state": {
                    "type": "bytes",
                    "key": "state"
                },
                "total_stake_sum": {
                    "type": "uint64",
                    "key": "total_stake_sum"
                },
                "user_address": {
                    "type": "bytes",
                    "key": "user_address"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "StressTesting",
        "methods": [
            {
                "name": "create",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Account of user that requested the test."
                    },
                    {
                        "type": "address",
                        "name": "owner_address",
                        "desc": "Account of owner of the funds used in the stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stake",
                        "desc": "Amount of stake used in the stress test. The value is expressed in microALGO."
                    },
                    {
                        "type": "uint64",
                        "name": "duration",
                        "desc": "Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing."
                    },
                    {
                        "type": "uint64",
                        "name": "duration_max",
                        "desc": "Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created."
                    }
                ],
                "returns": {
                    "type": "uint64",
                    "desc": "App ID of the created application."
                },
                "desc": "Creates a new contract for stress testing."
            },
            {
                "name": "start",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Account of user that requested the test."
                    },
                    {
                        "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
                        "name": "key_reg_info",
                        "desc": "Key registration information to use."
                    },
                    {
                        "type": "pay",
                        "name": "txn",
                        "desc": "Payment transaction for transfer of the requested stake and for covering the fee for reward registration."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Starts the stress test."
            },
            {
                "name": "end",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Account that requested the test to end."
                    }
                ],
                "returns": {
                    "type": "(bool,uint64,uint64,uint64,uint64,uint64,uint64,address)"
                },
                "desc": "Ends the stress test."
            },
            {
                "name": "record",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "Records a produced block during the stress test."
            },
            {
                "name": "unused",
                "args": [],
                "returns": {
                    "type": "uint64"
                },
                "desc": "Records a produced block during the stress test."
            }
        ],
        "networks": {},
        "desc": "\n    Escrow to be put online for the stress test by the user.\n    It allows counting of produced blocks.\n\n    Global state\n    ------------\n\n    user_address : arc4.Address\n        Account of user that requested the test.\n    owner_address : arc4.Address\n        Account of owner of the funds used in the stress test.\n\n    stake : UInt64\n        Amount of stake used in the stress test.\n        The value is expressed in microALGO.\n\n    duration : UInt64\n        Number of rounds for the stress test.\n        The actual duration of the block recording is 320 rounds shorter due to consensus trailing.\n    duration_max : UInt64\n        Maximum number of rounds allocated for the test, i.e. blocking of funds.\n        This is to take into account key generation time after the stress testing contract has been created.\n    round_created : UInt64\n        Round number when the request for the stress test is created.\n    round_start : UInt64\n        Round number when the actual participation in consensus starts.\n    round_end : UInt64\n        Round number when test should end.\n    round_ended : UInt64\n        Round number at which the contract ended.\n        Can be smaller than round_end in case of early test termination.\n    round_end_max : UInt64\n        Round number by which the stress test will be completed at the latest.\n\n    last_block : UInt64\n        Last block number that this contract account produced.\n    cnt_produced_blocks : UInt64\n        Counter of produced blocks.\n\n    total_stake_sum : UInt64\n        Sum for calculating the average of total online stake during the test.\n    cnt_total_stake_sum : UInt64\n        Counter for calculating the average of total online stake during the test.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            CREATED - contract has been created.\n            LIVE - contract is live.\n\n    Methods\n    -------\n    create(\n        user_address: arc4.Address,\n        owner_address: arc4.Address,\n        stake: UInt64,\n        duration: UInt64,\n        round_end_max: UInt64,\n    ) -> arc4.UInt64:\n        Creates a new contract for stress testing.\n\n    start(\n        user_address: arc4.Address,\n        key_reg_info: KeyRegTxnInfo,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Starts the stress test.\n\n    end(\n        user_address: arc4.Address,\n    ) -> ReturnStressTestingEnd:\n        Ends the stress test.\n\n    record(\n    ) -> None:\n        Records a produced block during the stress test.\n\n    unused(\n    ) -> None:\n        Records a produced block during the stress test.\n\n\n    "
    },
    "bare_call_config": {}
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class DeployCreate(algokit_utils.DeployCreateCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


@dataclasses.dataclass(kw_only=True)
class Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data) # type: ignore[call-overload]
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class KeyRegTxnInfo:
    vote_first: int
    vote_last: int
    vote_key_dilution: int
    vote_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    selection_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    sender: str


@dataclasses.dataclass(kw_only=True)
class StartArgs(_ArgsBase[None]):
    """Starts the stress test."""

    user_address: str
    """Account of user that requested the test."""
    key_reg_info: KeyRegTxnInfo
    """Key registration information to use."""
    txn: TransactionWithSigner
    """Payment transaction for transfer of the requested stake and for covering the fee for reward registration."""

    @staticmethod
    def method() -> str:
        return "start(address,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void"


@dataclasses.dataclass(kw_only=True)
class RecordArgs(_ArgsBase[None]):
    """Records a produced block during the stress test."""

    @staticmethod
    def method() -> str:
        return "record()void"


@dataclasses.dataclass(kw_only=True)
class CreateArgs(_ArgsBase[int]):
    """Creates a new contract for stress testing."""

    user_address: str
    """Account of user that requested the test."""
    owner_address: str
    """Account of owner of the funds used in the stress test."""
    stake: int
    """Amount of stake used in the stress test. The value is expressed in microALGO."""
    duration: int
    """Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing."""
    duration_max: int
    """Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created."""

    @staticmethod
    def method() -> str:
        return "create(address,address,uint64,uint64,uint64)uint64"


@dataclasses.dataclass(kw_only=True)
class ReturnStressTestingEnd:
    success: bool
    avr_online_stake: int
    cnt_produced_block: int
    round_start: int
    round_end: int
    round_ended: int
    stake: int
    user_address: str


@dataclasses.dataclass(kw_only=True)
class EndArgs(_ArgsBase[ReturnStressTestingEnd]):
    """Ends the stress test."""

    user_address: str
    """Account that requested the test to end."""

    @staticmethod
    def method() -> str:
        return "end(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,address)"


@dataclasses.dataclass(kw_only=True)
class UnusedArgs(_ArgsBase[int]):
    """Records a produced block during the stress test."""

    @staticmethod
    def method() -> str:
        return "unused()uint64"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.cnt_produced_blocks = typing.cast(int, data.get(b"cnt_produced_blocks"))
        self.cnt_total_stake_sum = typing.cast(int, data.get(b"cnt_total_stake_sum"))
        self.duration = typing.cast(int, data.get(b"duration"))
        self.duration_max = typing.cast(int, data.get(b"duration_max"))
        self.last_block = typing.cast(int, data.get(b"last_block"))
        self.owner_address = ByteReader(typing.cast(bytes, data.get(b"owner_address")))
        self.round_created = typing.cast(int, data.get(b"round_created"))
        self.round_end = typing.cast(int, data.get(b"round_end"))
        self.round_end_max = typing.cast(int, data.get(b"round_end_max"))
        self.round_ended = typing.cast(int, data.get(b"round_ended"))
        self.round_start = typing.cast(int, data.get(b"round_start"))
        self.stake = typing.cast(int, data.get(b"stake"))
        self.state = ByteReader(typing.cast(bytes, data.get(b"state")))
        self.total_stake_sum = typing.cast(int, data.get(b"total_stake_sum"))
        self.user_address = ByteReader(typing.cast(bytes, data.get(b"user_address")))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def start(
        self,
        *,
        user_address: str,
        key_reg_info: KeyRegTxnInfo,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Starts the stress test.
        
        Adds a call to `start(address,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param str user_address: Account of user that requested the test.
        :param KeyRegTxnInfo key_reg_info: Key registration information to use.
        :param TransactionWithSigner txn: Payment transaction for transfer of the requested stake and for covering the fee for reward registration.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StartArgs(
            user_address=user_address,
            key_reg_info=key_reg_info,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def record(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Records a produced block during the stress test.
        
        Adds a call to `record()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = RecordArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_create(
        self,
        *,
        user_address: str,
        owner_address: str,
        stake: int,
        duration: int,
        duration_max: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Creates a new contract for stress testing.
        
        Adds a call to `create(address,address,uint64,uint64,uint64)uint64` ABI method
        
        :param str user_address: Account of user that requested the test.
        :param str owner_address: Account of owner of the funds used in the stress test.
        :param int stake: Amount of stake used in the stress test. The value is expressed in microALGO.
        :param int duration: Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
        :param int duration_max: Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateArgs(
            user_address=user_address,
            owner_address=owner_address,
            stake=stake,
            duration=duration,
            duration_max=duration_max,
        )
        self.app_client.compose_create(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_end(
        self,
        *,
        user_address: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ends the stress test.
        
        Adds a call to `end(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,address)` ABI method
        
        :param str user_address: Account that requested the test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndArgs(
            user_address=user_address,
        )
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_unused(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Records a produced block during the stress test.
        
        Adds a call to `unused()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = UnusedArgs()
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class StressTestingClient:
    """
        Escrow to be put online for the stress test by the user.
        It allows counting of produced blocks.
    
        Global state
        ------------
    
        user_address : arc4.Address
            Account of user that requested the test.
        owner_address : arc4.Address
            Account of owner of the funds used in the stress test.
    
        stake : UInt64
            Amount of stake used in the stress test.
            The value is expressed in microALGO.
    
        duration : UInt64
            Number of rounds for the stress test.
            The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
        duration_max : UInt64
            Maximum number of rounds allocated for the test, i.e. blocking of funds.
            This is to take into account key generation time after the stress testing contract has been created.
        round_created : UInt64
            Round number when the request for the stress test is created.
        round_start : UInt64
            Round number when the actual participation in consensus starts.
        round_end : UInt64
            Round number when test should end.
        round_ended : UInt64
            Round number at which the contract ended.
            Can be smaller than round_end in case of early test termination.
        round_end_max : UInt64
            Round number by which the stress test will be completed at the latest.
    
        last_block : UInt64
            Last block number that this contract account produced.
        cnt_produced_blocks : UInt64
            Counter of produced blocks.
    
        total_stake_sum : UInt64
            Sum for calculating the average of total online stake during the test.
        cnt_total_stake_sum : UInt64
            Counter for calculating the average of total online stake during the test.
    
        state : Bytes
            State of the contract. Can be one of the following:
                CREATED - contract has been created.
                LIVE - contract is live.
    
        Methods
        -------
        create(
            user_address: arc4.Address,
            owner_address: arc4.Address,
            stake: UInt64,
            duration: UInt64,
            round_end_max: UInt64,
        ) -> arc4.UInt64:
            Creates a new contract for stress testing.
    
        start(
            user_address: arc4.Address,
            key_reg_info: KeyRegTxnInfo,
            txn: gtxn.PaymentTransaction,
        ) -> None:
            Starts the stress test.
    
        end(
            user_address: arc4.Address,
        ) -> ReturnStressTestingEnd:
            Ends the stress test.
    
        record(
        ) -> None:
            Records a produced block during the stress test.
    
        unused(
        ) -> None:
            Records a produced block during the stress test.
    
    
        
    
    A class for interacting with the StressTesting app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        StressTestingClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def start(
        self,
        *,
        user_address: str,
        key_reg_info: KeyRegTxnInfo,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Starts the stress test.
        
        Calls `start(address,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param str user_address: Account of user that requested the test.
        :param KeyRegTxnInfo key_reg_info: Key registration information to use.
        :param TransactionWithSigner txn: Payment transaction for transfer of the requested stake and for covering the fee for reward registration.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = StartArgs(
            user_address=user_address,
            key_reg_info=key_reg_info,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def record(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Records a produced block during the stress test.
        
        Calls `record()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = RecordArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_create(
        self,
        *,
        user_address: str,
        owner_address: str,
        stake: int,
        duration: int,
        duration_max: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a new contract for stress testing.
        
        Calls `create(address,address,uint64,uint64,uint64)uint64` ABI method
        
        :param str user_address: Account of user that requested the test.
        :param str owner_address: Account of owner of the funds used in the stress test.
        :param int stake: Amount of stake used in the stress test. The value is expressed in microALGO.
        :param int duration: Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
        :param int duration_max: Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: App ID of the created application."""

        args = CreateArgs(
            user_address=user_address,
            owner_address=owner_address,
            stake=stake,
            duration=duration,
            duration_max=duration_max,
        )
        result = self.app_client.create(
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return result

    def delete_end(
        self,
        *,
        user_address: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[ReturnStressTestingEnd]:
        """Ends the stress test.
        
        Calls `end(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,address)` ABI method
        
        :param str user_address: Account that requested the test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[ReturnStressTestingEnd]: The result of the transaction"""

        args = EndArgs(
            user_address=user_address,
        )
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = ReturnStressTestingEnd(**result_dict)
        return result

    def delete_unused(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Records a produced block during the stress test.
        
        Calls `unused()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = UnusedArgs()
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: DeployCreate[CreateArgs],
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: Deploy[EndArgs | UnusedArgs],
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param DeployCreate[CreateArgs] create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param Deploy[EndArgs | UnusedArgs] delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
