# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "cert_board_deploy()uint64": {
            "call_config": {
                "no_op": "CREATE"
            }
        },
        "cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void": {
            "structs": {
                "key_reg_info": {
                    "name": "KeyRegTxnInfo",
                    "elements": [
                        [
                            "vote_first",
                            "uint64"
                        ],
                        [
                            "vote_last",
                            "uint64"
                        ],
                        [
                            "vote_key_dilution",
                            "uint64"
                        ],
                        [
                            "vote_pk",
                            "byte[32]"
                        ],
                        [
                            "selection_pk",
                            "byte[32]"
                        ],
                        [
                            "state_proof_pk",
                            "byte[64]"
                        ],
                        [
                            "sender",
                            "address"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "cert_board_optin_asa(asset,account,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "cert_board_withdraw(uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "cert_create(address,byte[1024],pay,txn)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "cert_get(address,address)byte[1024]": {
            "read_only": true,
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_create(uint64,uint64,uint64,pay,txn)uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_end(address,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)": {
            "read_only": true,
            "structs": {
                "output": {
                    "name": "StressTestInfo",
                    "elements": [
                        [
                            "avr_online_stake",
                            "uint64"
                        ],
                        [
                            "cnt_produced_block",
                            "uint64"
                        ],
                        [
                            "round_start",
                            "uint64"
                        ],
                        [
                            "round_end",
                            "uint64"
                        ],
                        [
                            "stake",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_record(address,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void": {
            "structs": {
                "key_reg_info": {
                    "name": "KeyRegTxnInfo",
                    "elements": [
                        [
                            "vote_first",
                            "uint64"
                        ],
                        [
                            "vote_last",
                            "uint64"
                        ],
                        [
                            "vote_key_dilution",
                            "uint64"
                        ],
                        [
                            "vote_pk",
                            "byte[32]"
                        ],
                        [
                            "selection_pk",
                            "byte[32]"
                        ],
                        [
                            "state_proof_pk",
                            "byte[64]"
                        ],
                        [
                            "sender",
                            "address"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "stress_unused(address,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgY2FsbHN1YiBfX3B1eWFfYXJjNF9yb3V0ZXJfXwogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLl9fcHV5YV9hcmM0X3JvdXRlcl9fKCkgLT4gdWludDY0OgpfX3B1eWFfYXJjNF9yb3V0ZXJfXzoKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMTgKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9kZXBsb3koKXVpbnQ2NCIKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9rZXlfcmVnKCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSxwYXkpdm9pZCIKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9zZXQoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICBtZXRob2QgImNlcnRfYm9hcmRfb3B0aW5fYXNhKGFzc2V0LGFjY291bnQscGF5KXZvaWQiCiAgICBtZXRob2QgImNlcnRfYm9hcmRfd2l0aGRyYXcodWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJjZXJ0X2NyZWF0ZShhZGRyZXNzLGJ5dGVbMTAyNF0scGF5LHR4bil2b2lkIgogICAgbWV0aG9kICJjZXJ0X2dldChhZGRyZXNzLGFkZHJlc3MpYnl0ZVsxMDI0XSIKICAgIG1ldGhvZCAic3RyZXNzX2NyZWF0ZSh1aW50NjQsdWludDY0LHVpbnQ2NCxwYXksdHhuKXVpbnQ2NCIKICAgIG1ldGhvZCAic3RyZXNzX2VuZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzdHJlc3NfZ2V0KGFkZHJlc3MsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIG1ldGhvZCAic3RyZXNzX3JlY29yZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzdHJlc3Nfc3RhcnQodWludDY0LCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSxwYXkpdm9pZCIKICAgIG1ldGhvZCAic3RyZXNzX3VudXNlZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF9kZXBsb3lfcm91dGVAMiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2JvYXJkX2tleV9yZWdfcm91dGVAMyBfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2JvYXJkX3NldF9yb3V0ZUA0IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfb3B0aW5fYXNhX3JvdXRlQDUgX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF93aXRoZHJhd19yb3V0ZUA2IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfY3JlYXRlX3JvdXRlQDcgX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9nZXRfcm91dGVAOCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19zdHJlc3NfY3JlYXRlX3JvdXRlQDkgX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2VuZF9yb3V0ZUAxMCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19zdHJlc3NfZ2V0X3JvdXRlQDExIF9fcHV5YV9hcmM0X3JvdXRlcl9fX3N0cmVzc19yZWNvcmRfcm91dGVAMTIgX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3N0YXJ0X3JvdXRlQDEzIF9fcHV5YV9hcmM0X3JvdXRlcl9fX3N0cmVzc191bnVzZWRfcm91dGVAMTQKICAgIGludCAwCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfZGVwbG95X3JvdXRlQDI6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gaXMgY3JlYXRpbmcKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9kZXBsb3kKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfa2V5X3JlZ19yb3V0ZUAzOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICBjYWxsc3ViIGNlcnRfYm9hcmRfa2V5X3JlZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF9zZXRfcm91dGVANDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGJ0b2kKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9zZXQKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfb3B0aW5fYXNhX3JvdXRlQDU6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBc3NldHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9vcHRpbl9hc2EKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfd2l0aGRyYXdfcm91dGVANjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgY2VydF9ib2FyZF93aXRoZHJhdwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9jcmVhdGVfcm91dGVANzoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBjYWxsc3ViIGNlcnRfY3JlYXRlCiAgICBpbnQgMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2dldF9yb3V0ZUA4OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgY2FsbHN1YiBjZXJ0X2dldAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2NyZWF0ZV9yb3V0ZUA5OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGNhbGxzdWIgc3RyZXNzX2NyZWF0ZQogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2VuZF9yb3V0ZUAxMDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX2VuZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2dldF9yb3V0ZUAxMToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX2dldAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3JlY29yZF9yb3V0ZUAxMjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX3JlY29yZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3N0YXJ0X3JvdXRlQDEzOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICBjYWxsc3ViIHN0cmVzc19zdGFydAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3VudXNlZF9yb3V0ZUAxNDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX3VudXNlZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYWZ0ZXJfaWZfZWxzZUAxODoKICAgIGludCAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9ib2FyZF9kZXBsb3koKSAtPiBieXRlczoKY2VydF9ib2FyZF9kZXBsb3k6CiAgICBwcm90byAwIDEKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3RhdGUiCiAgICBieXRlIDB4MDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2JvYXJkX2tleV9yZWcoa2V5X3JlZ19pbmZvOiBieXRlcywgdHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNlcnRfYm9hcmRfa2V5X3JlZzoKICAgIHByb3RvIDIgMAogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsYV9tYW5hZ2VyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgcGxhdGZvcm0gbWFuYWdlci4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAxNiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDg4IDY0IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDE1MiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIFN0YXRlUHJvb2ZQSwogICAgaXR4bl9maWVsZCBWb3RlS2V5RGlsdXRpb24KICAgIGl0eG5fZmllbGQgVm90ZUxhc3QKICAgIGl0eG5fZmllbGQgVm90ZUZpcnN0CiAgICBpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCiAgICBpdHhuX2ZpZWxkIFZvdGVQSwogICAgaW50IGtleXJlZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9ib2FyZF9zZXQocGxhX21hbmFnZXI6IGJ5dGVzLCBleHBlY3RlZF9jb25zZW5zdXNfcmF0ZTogdWludDY0LCBjZXJ0aWZpY2F0ZV9mZWU6IHVpbnQ2NCwgc3RyZXNzX3Rlc3RfZmVlX3JvdW5kOiB1aW50NjQsIHBheW1lbnRfYXNzZXQ6IHVpbnQ2NCwgbWF4X3Rlc3RfZHVyYXRpb246IHVpbnQ2NCwgbWF4X3Rlc3RfYmxvY2tpbmc6IHVpbnQ2NCwgc3Rha2VfbWluOiB1aW50NjQsIHN0YWtlX21heDogdWludDY0KSAtPiB2b2lkOgpjZXJ0X2JvYXJkX3NldDoKICAgIHByb3RvIDkgMAogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsYV9tYW5hZ2VyIGV4aXN0cwogICAgPT0KICAgIGJueiBjZXJ0X2JvYXJkX3NldF9ib29sX3RydWVAMgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYnogY2VydF9ib2FyZF9zZXRfYm9vbF9mYWxzZUAzCgpjZXJ0X2JvYXJkX3NldF9ib29sX3RydWVAMjoKICAgIGludCAxCiAgICBiIGNlcnRfYm9hcmRfc2V0X2Jvb2xfbWVyZ2VANAoKY2VydF9ib2FyZF9zZXRfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCmNlcnRfYm9hcmRfc2V0X2Jvb2xfbWVyZ2VANDoKICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgcGxhdGZvcm0gbWFuYWdlciBvciBjcmVhdG9yLgogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBmcmFtZV9kaWcgLTkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJleHBlY3RlZF9jb25zZW5zdXNfcmF0ZSIKICAgIGZyYW1lX2RpZyAtOAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGZyYW1lX2RpZyAtNwogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0cmVzc190ZXN0X2ZlZV9yb3VuZCIKICAgIGZyYW1lX2RpZyAtNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJtYXhfdGVzdF9kdXJhdGlvbiIKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgIm1heF90ZXN0X2Jsb2NraW5nIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWluIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgaW50IDAKICAgIGJ5dGUgInN0YWtlX21pbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGFrZV9taW4gZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YWtlX21heCBleGlzdHMKICAgIDwKICAgIGFzc2VydCAvLyBNYXggc3Rha2UgbXVzdCBiZSBsYXJnZXIgdGhhbiBtaW4uCiAgICBpbnQgMAogICAgYnl0ZSAibWF4X3Rlc3RfZHVyYXRpb24iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWF4X3Rlc3RfZHVyYXRpb24gZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAibWF4X3Rlc3RfYmxvY2tpbmciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWF4X3Rlc3RfYmxvY2tpbmcgZXhpc3RzCiAgICA8CiAgICBhc3NlcnQgLy8gTWF4IGR1cmF0aW9uIG11c3QgYmUgc21hbGxlciB0aGFuIG1heCByZXF1ZXN0cyBibG9jayByb3VuZHMuCiAgICBmcmFtZV9kaWcgLTUKICAgIGJ6IGNlcnRfYm9hcmRfc2V0X2FmdGVyX2lmX2Vsc2VANgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtNQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBOb3Qgb3B0ZWQgaW50byBhc3NldC4KCmNlcnRfYm9hcmRfc2V0X2FmdGVyX2lmX2Vsc2VANjoKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLmNlcnRfYm9hcmRfb3B0aW5fYXNhKGFzYTogdWludDY0LCBzZW5kZXI6IGJ5dGVzLCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKY2VydF9ib2FyZF9vcHRpbl9hc2E6CiAgICBwcm90byAzIDAKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJwbGFfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wbGFfbWFuYWdlciBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHBsYXRmb3JtIG1hbmFnZXIuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIE1CUiBpbmNyZWFzZSBmb3Igb3B0aW5nIGludG8gYW4gQVNBLgogICAgaXR4bl9iZWdpbgogICAgaW50IDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnQgYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2JvYXJkX3dpdGhkcmF3KGFtb3VudDogdWludDY0LCBhc3NldF9pZDogdWludDY0KSAtPiB2b2lkOgpjZXJ0X2JvYXJkX3dpdGhkcmF3OgogICAgcHJvdG8gMiAwCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBwbGF0Zm9ybSBtYW5hZ2VyLgogICAgZnJhbWVfZGlnIC0xCiAgICBieiBjZXJ0X2JvYXJkX3dpdGhkcmF3X2Vsc2VfYm9keUAzCiAgICBpdHhuX2JlZ2luCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgaW50IGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIGNlcnRfYm9hcmRfd2l0aGRyYXdfYWZ0ZXJfaWZfZWxzZUA1CgpjZXJ0X2JvYXJkX3dpdGhkcmF3X2Vsc2VfYm9keUAzOgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYmxvY2tlZF9hbGdvIGV4aXN0cwogICAgLQogICAgZnJhbWVfZGlnIC0yCiAgICA+PQogICAgYXNzZXJ0IC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggYXZhaWxhYmxlIEFMR08gZm9yIHdpdGhkcmF3YWwuCiAgICBpdHhuX2JlZ2luCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpbnQgcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpjZXJ0X2JvYXJkX3dpdGhkcmF3X2FmdGVyX2lmX2Vsc2VANToKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2NyZWF0ZShyZWNpcGllbnQ6IGJ5dGVzLCBpbmZvOiBieXRlcywgbWJyX3R4bjogdWludDY0LCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKY2VydF9jcmVhdGU6CiAgICBwcm90byA0IDAKICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBmcmFtZV9kaWcgLTQKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBib3hfcHV0CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIC0KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludCBwYXkKICAgID09CiAgICBieiBjZXJ0X2NyZWF0ZV9lbHNlX2JvZHlAMgogICAgaW50IDAKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGF5bWVudF9hc3NldCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jZXJ0aWZpY2F0ZV9mZWUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIGNlcnRfY3JlYXRlX2FmdGVyX2lmX2Vsc2VANgoKY2VydF9jcmVhdGVfZWxzZV9ib2R5QDI6CiAgICBmcmFtZV9kaWcgMAogICAgaW50IGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIHR5cGUgbXVzdCBiZSBlaXRoZXIgUGF5bWVudCBvciBBc3NldFRyYW5zZmVyLgogICAgaW50IDAKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGF5bWVudF9hc3NldCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgWGZlckFzc2V0CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldEFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jZXJ0aWZpY2F0ZV9mZWUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCgpjZXJ0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDY6CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9nZXQocmVjaXBpZW50OiBieXRlcywgaXNzdWVyOiBieXRlcykgLT4gYnl0ZXM6CmNlcnRfZ2V0OgogICAgcHJvdG8gMiAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBCb3ggZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuc3RyZXNzX2NyZWF0ZShzdGFrZTogdWludDY0LCBkdXJhdGlvbjogdWludDY0LCBkdXJhdGlvbl9tYXg6IHVpbnQ2NCwgYWxnb190eG46IHVpbnQ2NCwgdHhuOiB1aW50NjQpIC0+IGJ5dGVzOgpzdHJlc3NfY3JlYXRlOgogICAgcHJvdG8gNSAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGludCAwCiAgICBieXRlICJzdGFrZV9tYXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2VfbWF4IGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICA+CiAgICBhc3NlcnQgLy8gUmVxdWVzdGVkIHN0YWtlIGZvciB0aGUgc3RyZXNzIHRlc3QgaXMgbGFyZ2VyIHRoYW4gYWxsb3dlZC4KICAgIGludCAwCiAgICBieXRlICJzdGFrZV9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2VfbWluIGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICA8CiAgICBhc3NlcnQgLy8gUmVxdWVzdGVkIHN0YWtlIGZvciB0aGUgc3RyZXNzIHRlc3QgaXMgc21hbGxlciB0aGFuIGFsbG93ZWQuCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHR4biBTZW5kZXIKICAgIGl0eG5fYmVnaW4KICAgIGludCAwCiAgICBieXRlICJwbGFfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wbGFfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtNQogICAgaXRvYgogICAgZnJhbWVfZGlnIC00CiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIGludCAxMgogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1VaW50CiAgICBpbnQgMwogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIGJ5dGUgYmFzZTY0IENvRUJRdz09CiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIGJ5dGUgYmFzZTY0IENpQUVBQUVGcXIyREZDWVRDM0p2ZFc1a1gyVnVaR1ZrQlhOMFlYUmxDWEp2ZFc1a1gyVnVaQWhrZFhKaGRHbHZiZ1Z6ZEdGclpSTmpiblJmY0hKdlpIVmpaV1JmWW14dlkydHpEM1J2ZEdGc1gzTjBZV3RsWDNOMWJSTmpiblJmZEc5MFlXeGZjM1JoYTJWZmMzVnREWEp2ZFc1a1gyVnVaRjl0WVhnTWRYTmxjbDloWkdSeVpYTnpER1IxY21GMGFXOXVYMjFoZUExeWIzVnVaRjlqY21WaGRHVmtDM0p2ZFc1a1gzTjBZWEowQ214aGMzUmZZbXh2WTJzRUZSOThkUTF2ZDI1bGNsOWhaR1J5WlhOekFRRUJBZ0VBTVJoQUFBT0lBdDJJQUFGRGlnQUJNUnRCQUorQ0JRUnFwdm1JQkYzeW9Cd0VybU5DQkFTR0pxWVdCSFd4M1VBMkdnQ09CUUFDQUNZQVFnQlhBR01paVRFWkZFUXhHQlJFTmhvQk5ob0NOaG9ERnpZYUJCYzJHZ1VYaUFCWUp3NU1VTEFqaVRFWkZFUXhHRVEyR2dFMkdnSXhGaU1KU1RnUUl4SkVpQUNUSTRreEdTUVNSREVZUkRZYUFZZ0JOaWNPVEZDd0k0a3hHUlJFTVJoRWlBSENJNGt4R1NRU1JERVlSSWdDQVNjT1RGQ3dJNGtpaVlvRkFTY0ppL3RuSncrTC9HY25CSXY5Wnl1TC9tY25Db3YvWnlpQmdNTFhMMmNuQlNKbkp3WWxaeWNISTJjcEp4Qm5Kd3N5Qm1jaUp3dGxSQ0luQ21WRUNDY0lUR2NpSzJWRUlpY0taVVFNUkNJclpVUWpEVVF5Q0JhSmlnTUFNUUF5Q1JKRUlpbGxSQ2NRRWtRaUp3bGxSSXY5RWtReUJpSXJaVVFJS2t4bklpcGxSQ0luQ0dWRURFU0wvemdITWdvU1JDSW5CR1ZFaS84NENCSkVNZ1lqQ0NjTVRHY2lKd3hsUkNjTlRHZUwvbGNBQ0JjaUp3dGxSRXNCRWtTTC9sY0lDQmNpSndobFJFc0JFa1NML2xlWUlFa3lDaEpFc1l2K1Z4Z2dUSXYrVnpnZ2kvNVhFQWdYaS81WFdFQlBBN0lBc2oreURrOENzZzFQQXJJTXNndXlDb0VDc2hBaXNnR3pLU2NSWjRtS0FRRXhBRElKRWtRaUtXVkVKeEVTUkNneUJtY2lKdzlsUkl2L0VrRUFGQ0lvWlVRaUttVkVERUVBQkNKQ0FCQWpRZ0FNSWlobFJDSXFaVVFNRkVRanNUSUpTYklKSXJJSXNnY2pzaEFpc2dHeklpY0daVVFpSndkbFJBb25FaUpQQTFSTUZpSW5CV1ZFRmlJbkRHVkVGaUlxWlVRV0lpaGxSQllpSndSbFJCWWlKd2xsUkU4SFR3ZFFUd1pRVHdWUVR3UlFUd05RVHdKUVRGQ0ppZ0FBSWlsbFJDY1JFa1F5QmlJb1pVUU1SRElHSWlwbFJFc0JEVVFpSncxbFJFc0JERVFpSndWbFJDTUlKd1ZNWnljTlRHY2lKd1psUkNVSUp3Wk1aeUluQjJWRUl3Z25CMHhuaVlvQUFURUFNZ2tTUkNJcFpVUW5FQkpFTWdZaUsyVkVDQ0luQ0dWRURVU3hNZ2xKc2draXNnaXlCeU95RUNLeUFiTWlKd1JsUkJhSmlnQUFKd2t5QTJjbkR6SURaeWNFSW1jckltY25DaUpuSndzaVp5Y01JbWNxSW1jb0ltY25DQ0puSncwaVp5Y0ZJbWNuQmlKbkp3Y2paeWtuRW1lSgogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgbWV0aG9kICJjcmVhdGUoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIGludCAwCiAgICBieXRlICJzdHJlc3NfdGVzdF9mZWVfcm91bmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RyZXNzX3Rlc3RfZmVlX3JvdW5kIGV4aXN0cwogICAgZnJhbWVfZGlnIC0zCiAgICAqCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludCBwYXkKICAgID09CiAgICBieiBzdHJlc3NfY3JlYXRlX2Vsc2VfYm9keUAzCiAgICBpbnQgMAogICAgYnl0ZSAicGF5bWVudF9hc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wYXltZW50X2Fzc2V0IGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIHN0cmVzc19jcmVhdGVfYWZ0ZXJfaWZfZWxzZUA3CgpzdHJlc3NfY3JlYXRlX2Vsc2VfYm9keUAzOgogICAgZnJhbWVfZGlnIDIKICAgIGludCBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiB0eXBlIG11c3QgYmUgZWl0aGVyIFBheW1lbnQgb3IgQXNzZXRUcmFuc2Zlci4KICAgIGludCAwCiAgICBieXRlICJwYXltZW50X2Fzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBheW1lbnRfYXNzZXQgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFhmZXJBc3NldAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgID09CiAgICBhc3NlcnQgLy8gU2VudCBhbW91bnQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KCnN0cmVzc19jcmVhdGVfYWZ0ZXJfaWZfZWxzZUA3OgogICAgaW50IDAKICAgIGJ5dGUgImV4cGVjdGVkX2NvbnNlbnN1c19yYXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmV4cGVjdGVkX2NvbnNlbnN1c19yYXRlIGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICAqCiAgICBmcmFtZV9kaWcgLTMKICAgICoKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgZnJhbWVfZGlnIDAKICAgIC0KICAgIGRpZyAxCiAgICArCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgPAogICAgYXNzZXJ0CiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbGdvIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJsb2NrZWRfYWxnbyBleGlzdHMKICAgIGZyYW1lX2RpZyAtNQogICAgdW5jb3ZlciAyCiAgICArCiAgICArCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc19lbmQodXNlcl9hZGRyZXNzOiBieXRlcywgc3RyZXNzX3Rlc3RfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc3RyZXNzX2VuZDoKICAgIHByb3RvIDIgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFVzZXIgYWRkcmVzcyBhbmQgc3RyZXNzIHRlc3QgSUQgY29tYmluYXRpb24gYXJlIG5vdCBmb3VuZCBhdCB0aGUgcGxhdGZvcm0uCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdHJlc3NfdGVzdHMgZW50cnkgZXhpc3RzCiAgICBjYWxsc3ViIF9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0CiAgICA9PQogICAgYXNzZXJ0IC8vIFN0cmVzcyB0ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkLgogICAgaXR4bl9iZWdpbgogICAgdHhuIFNlbmRlcgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAiZW5kKGFkZHJlc3MpKGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBkaWcgMQogICAgZXh0cmFjdCA0MSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBjb3ZlciA0CiAgICBidG9pCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgaW50IDAKICAgIGdldGJpdAogICAgYnl0ZSAweDAwCiAgICBpbnQgMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGUgMHgwMAogICAgIT0KICAgIGJ6IHN0cmVzc19lbmRfZWxzZV9ib2R5QDMKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGV4dHJhY3QgMSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgc3dhcAogICAgZHVwCiAgICBleHRyYWN0IDkgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIGR1cAogICAgZXh0cmFjdCAxNyA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgY292ZXIgMgogICAgZXh0cmFjdCAyNSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgMQogICAgY29uY2F0CiAgICBib3hfcHV0CiAgICBiIHN0cmVzc19lbmRfYWZ0ZXJfaWZfZWxzZUA0CgpzdHJlc3NfZW5kX2Vsc2VfYm9keUAzOgogICAgYm94X2RlbAogICAgYXNzZXJ0CgpzdHJlc3NfZW5kX2FmdGVyX2lmX2Vsc2VANDoKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0Ll9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0KCkgLT4gYnl0ZXM6Cl9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0OgogICAgcHJvdG8gMCAxCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5zdHJlc3NfZ2V0KHJlY2lwaWVudDogYnl0ZXMsIHN0cmVzc190ZXN0X2lkOiB1aW50NjQpIC0+IGJ5dGVzOgpzdHJlc3NfZ2V0OgogICAgcHJvdG8gMiAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0cmVzc190ZXN0cyBlbnRyeSBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5zdHJlc3NfcmVjb3JkKHVzZXJfYWRkcmVzczogYnl0ZXMsIHN0cmVzc190ZXN0X2lkOiB1aW50NjQpIC0+IHZvaWQ6CnN0cmVzc19yZWNvcmQ6CiAgICBwcm90byAyIDAKICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBVc2VyIGFkZHJlc3MgYW5kIHN0cmVzcyB0ZXN0IElEIGNvbWJpbmF0aW9uIGFyZSBub3QgZm91bmQgYXQgdGhlIHBsYXRmb3JtLgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RyZXNzX3Rlc3RzIGVudHJ5IGV4aXN0cwogICAgY2FsbHN1YiBfZ2V0X3N0cmVzc190ZXN0X2luZm9faW5pdAogICAgPT0KICAgIGFzc2VydCAvLyBTdHJlc3MgdGVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZC4KICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInJlY29yZCgpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc19zdGFydChzdHJlc3NfdGVzdF9pZDogdWludDY0LCBrZXlfcmVnX2luZm86IGJ5dGVzLCBtYnJfdHhuOiB1aW50NjQpIC0+IHZvaWQ6CnN0cmVzc19zdGFydDoKICAgIHByb3RvIDMgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMwogICAgYnl0ZSAweDc1NzM2NTcyNWY2MTY0NjQ3MjY1NzM3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydAogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgZGlnIDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY2FsbHN1YiBfZ2V0X3N0cmVzc190ZXN0X2luZm9faW5pdAogICAgYm94X3B1dAogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlIDB4NzM3NDYxNmI2NQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydAogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX25leHQKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInN0YXJ0KGFkZHJlc3MsKHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLGFkZHJlc3MpLHBheSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBzd2FwCiAgICAtCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc191bnVzZWQodXNlcl9hZGRyZXNzOiBieXRlcywgc3RyZXNzX3Rlc3RfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc3RyZXNzX3VudXNlZDoKICAgIHByb3RvIDIgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9idXJ5IC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgMHg3NTczNjU3MjVmNjE2NDY0NzI2NTczNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMgogICAgPT0KICAgIGFzc2VydAogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgaXR4bl9iZWdpbgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAidW51c2VkKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBzd2FwCiAgICBidG9pCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLl9faW5pdF9fKCkgLT4gdm9pZDoKX19pbml0X186CiAgICBwcm90byAwIDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAiZXhwZWN0ZWRfY29uc2Vuc3VzX3JhdGUiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3RyZXNzX3Rlc3RfZmVlX3JvdW5kIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJwYXltZW50X2Fzc2V0IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJtYXhfdGVzdF9kdXJhdGlvbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAibWF4X3Rlc3RfYmxvY2tpbmciCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YWtlX21pbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIGludCAxCiAgICByZXR1cm4K"
    },
    "state": {
        "global": {
            "num_byte_slices": 2,
            "num_uints": 9
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "blocked_algo": {
                    "type": "uint64",
                    "key": "blocked_algo"
                },
                "certificate_fee": {
                    "type": "uint64",
                    "key": "certificate_fee"
                },
                "expected_consensus_rate": {
                    "type": "uint64",
                    "key": "expected_consensus_rate"
                },
                "max_test_blocking": {
                    "type": "uint64",
                    "key": "max_test_blocking"
                },
                "max_test_duration": {
                    "type": "uint64",
                    "key": "max_test_duration"
                },
                "payment_asset": {
                    "type": "uint64",
                    "key": "payment_asset"
                },
                "pla_manager": {
                    "type": "bytes",
                    "key": "pla_manager"
                },
                "stake_max": {
                    "type": "uint64",
                    "key": "stake_max"
                },
                "stake_min": {
                    "type": "uint64",
                    "key": "stake_min"
                },
                "state": {
                    "type": "bytes",
                    "key": "state"
                },
                "stress_test_fee_round": {
                    "type": "uint64",
                    "key": "stress_test_fee_round"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "CertBoard",
        "methods": [
            {
                "name": "cert_board_deploy",
                "args": [],
                "returns": {
                    "type": "uint64",
                    "desc": "App ID of the created application."
                },
                "desc": "Creates a new CertBoard."
            },
            {
                "name": "cert_board_key_reg",
                "args": [
                    {
                        "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
                        "name": "key_reg_info",
                        "desc": "Key registration information to send."
                    },
                    {
                        "type": "pay",
                        "name": "txn",
                        "desc": "Payment transaction to cover costs for the key (de)registration fee."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Issues a key (de)registration transaction by the platform."
            },
            {
                "name": "cert_board_set",
                "args": [
                    {
                        "type": "address",
                        "name": "pla_manager",
                        "desc": "Platform manager account."
                    },
                    {
                        "type": "uint64",
                        "name": "expected_consensus_rate",
                        "desc": "Expected consensus reward rate. Expressed as percentage per year."
                    },
                    {
                        "type": "uint64",
                        "name": "certificate_fee",
                        "desc": "Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately."
                    },
                    {
                        "type": "uint64",
                        "name": "stress_test_fee_round",
                        "desc": "Amount charged per round of the stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "payment_asset",
                        "desc": "Payment method for the stress test and certificate fee."
                    },
                    {
                        "type": "uint64",
                        "name": "max_test_duration",
                        "desc": "Maximum allowed duration for a stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "max_test_blocking",
                        "desc": "Maximum amount of rounds allowed to reserve for a stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stake_min",
                        "desc": "Minimum stake allowed to be used for a stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stake_max",
                        "desc": "Maximum stake allowed to be used for a stress test."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Sets platform parameters (anew)."
            },
            {
                "name": "cert_board_optin_asa",
                "args": [
                    {
                        "type": "asset",
                        "name": "asa",
                        "desc": "Asset to opt into."
                    },
                    {
                        "type": "account",
                        "name": "sender",
                        "desc": "Account to opt into the asa."
                    },
                    {
                        "type": "pay",
                        "name": "txn",
                        "desc": "Payment transaction to cover MBR increase."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Opts the platform address in to an ASA."
            },
            {
                "name": "cert_board_withdraw",
                "args": [
                    {
                        "type": "uint64",
                        "name": "amount",
                        "desc": "Amount to withdraw from the platform."
                    },
                    {
                        "type": "uint64",
                        "name": "asset_id",
                        "desc": "ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Platform owner withdraws amount of asset from the platform."
            },
            {
                "name": "cert_create",
                "args": [
                    {
                        "type": "address",
                        "name": "recipient",
                        "desc": "Recipient of the certificate."
                    },
                    {
                        "type": "byte[1024]",
                        "name": "info",
                        "desc": "Information to be recorded in the certificate."
                    },
                    {
                        "type": "pay",
                        "name": "mbr_txn",
                        "desc": "Payment transaction for the payment of the increase of platform MBR due to creation of the certificate."
                    },
                    {
                        "type": "txn",
                        "name": "txn",
                        "desc": "Transaction for the payment of the certificate issuance fee."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "An issuer creates a certificate stored on the platform."
            },
            {
                "name": "cert_get",
                "args": [
                    {
                        "type": "address",
                        "name": "recipient",
                        "desc": "Recipient of the certificate."
                    },
                    {
                        "type": "address",
                        "name": "issuer",
                        "desc": "Issuer of the certificate."
                    }
                ],
                "returns": {
                    "type": "byte[1024]"
                },
                "desc": "Returns the certificate issued by issuer to the recipient."
            },
            {
                "name": "stress_create",
                "args": [
                    {
                        "type": "uint64",
                        "name": "stake",
                        "desc": "Amount of stake used in the stress test. The value is expressed in microALGO."
                    },
                    {
                        "type": "uint64",
                        "name": "duration",
                        "desc": "Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing."
                    },
                    {
                        "type": "uint64",
                        "name": "duration_max",
                        "desc": "Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created."
                    },
                    {
                        "type": "pay",
                        "name": "algo_txn",
                        "desc": "Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test."
                    },
                    {
                        "type": "txn",
                        "name": "txn",
                        "desc": "Transaction for the payment of the stress test fee."
                    }
                ],
                "returns": {
                    "type": "uint64"
                },
                "desc": "Creates a stress test."
            },
            {
                "name": "stress_end",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Address of the user that initiated the stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stress_test_id",
                        "desc": "App ID of the stress test to end."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Ends a stress test."
            },
            {
                "name": "stress_get",
                "args": [
                    {
                        "type": "address",
                        "name": "recipient",
                        "desc": "Recipient of the certificate."
                    },
                    {
                        "type": "uint64",
                        "name": "stress_test_id",
                        "desc": "App ID of the stress test to end."
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64,uint64,uint64,uint64)"
                },
                "desc": "Gets information about a successfully finished stress test."
            },
            {
                "name": "stress_record",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Address of the user that initiated the stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stress_test_id",
                        "desc": "App ID of the stress test to end."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Records a produced block of during the stress test."
            },
            {
                "name": "stress_start",
                "args": [
                    {
                        "type": "uint64",
                        "name": "stress_test_id",
                        "desc": "App ID of the stress test to end."
                    },
                    {
                        "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
                        "name": "key_reg_info"
                    },
                    {
                        "type": "pay",
                        "name": "mbr_txn",
                        "desc": "Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Starts a created test."
            },
            {
                "name": "stress_unused",
                "args": [
                    {
                        "type": "address",
                        "name": "user_address",
                        "desc": "Address of the user that initiated the stress test."
                    },
                    {
                        "type": "uint64",
                        "name": "stress_test_id",
                        "desc": "App ID of the stress test to end."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Ends a not used stress test."
            }
        ],
        "networks": {},
        "desc": "\n    Certification Board servers as decentralized registrar for certificates to build trust in\n    the node running capabilities of an entity.\n    It supports issuing of attestations according to applicable node running standards by any entity.\n    Moreover, it supports generation of on-chain produced proofs of an entity's node running\n    capabilities through self-initiated stress tests, which get recorded as another certificate type.\n\n    Global state\n    ------------\n\n    pla_manager : Account\n        Platform manager account.\n\n    expected_consensus_rate : UInt64\n        Expected consensus reward rate.\n        Expressed as percentage per year.\n\n    certificate_fee : UInt64\n        Fee charged by the platform for issuing of a certificate by anyone.\n        Note: MBR increase is paid separately.\n    stress_test_fee_round : UInt64\n        Amount charged per round of the stress test.\n    payment_asset : UInt64\n        Payment method for the stress test and certificate fee.\n\n    max_test_duration : UInt64\n        Maximum allowed duration for a stress test.\n    max_test_blocking : UInt64\n        Maximum amount of rounds allowed to reserve for a stress test.\n\n    stake_min : UInt64\n        Minimum stake allowed to be used for a stress test.\n    stake_max : UInt64\n        Maximum stake allowed to be used for a stress test.\n\n    blocked_algo: UInt64\n        Amount of ALGO currently blocked and awaiting to be used in started stress test(s) requests.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            DEPLOYED - CertBoard has been created.\n            LIVE - CertBoard is live.\n\n    Methods\n    -------\n    cert_board_deploy(\n    ) -> arc4.UInt64:\n        Creates a new CertBoard.\n\n    cert_board_key_reg(\n        key_reg_info: KeyRegTxnInfo,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Issues a key (de)registration transaction by the platform.\n\n    cert_board_set(\n        pla_manager: arc4.Address,\n        expected_consensus_rate: UInt64,\n        certificate_fee: UInt64,\n        stress_test_fee_round: UInt64,\n        payment_asset: UInt64,\n        max_test_duration: UInt64,\n        max_test_blocking: UInt64,\n        stake_min: UInt64,\n        stake_max: UInt64,\n    ) -> None:\n        Sets platform parameters (anew).\n\n    cert_board_optin_asa(\n        asa: Asset,\n        sender: Account,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Opts the platform address in to an ASA.\n\n    cert_board_withdraw(\n        amount: UInt64,\n        asset_id: UInt64,\n    ) -> None:\n        Platform owner withdraws amount of asset from the platform.\n\n    cert_create(\n        recipient: arc4.Address,\n        info: CertInfo,\n        mbr_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> None:\n        An issuer creates a certificate stored on the platform.\n\n    cert_get(\n        recipient: arc4.Address,\n        issuer: arc4.Address,\n    ) -> CertInfo:\n        Returns the certificate issued by issuer to the recipient.\n\n    stress_create(\n        stake: UInt64,\n        duration: UInt64,\n        round_end_max: UInt64,\n        algo_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> arc4.UInt64:\n        Creates a stress test.\n\n    stress_end(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Ends a stress test.\n\n    stress_get(\n        recipient: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> StressTestInfo:\n        Gets information about a successfully finished stress test.\n\n    stress_record(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Records a produced block of during the stress test.\n\n    stress_start(\n        stress_test_id: UInt64,\n        key_reg_info: KeyRegTxnInfo,\n    ) -> None:\n        Starts a created test.\n\n    stress_unused(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Ends a not used stress test.\n\n    "
    },
    "bare_call_config": {}
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class DeployCreate(algokit_utils.DeployCreateCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data) # type: ignore[call-overload]
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class KeyRegTxnInfo:
    vote_first: int
    vote_last: int
    vote_key_dilution: int
    vote_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    selection_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    sender: str


@dataclasses.dataclass(kw_only=True)
class CertBoardKeyRegArgs(_ArgsBase[None]):
    """Issues a key (de)registration transaction by the platform."""

    key_reg_info: KeyRegTxnInfo
    """Key registration information to send."""
    txn: TransactionWithSigner
    """Payment transaction to cover costs for the key (de)registration fee."""

    @staticmethod
    def method() -> str:
        return "cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void"


@dataclasses.dataclass(kw_only=True)
class CertBoardSetArgs(_ArgsBase[None]):
    """Sets platform parameters (anew)."""

    pla_manager: str
    """Platform manager account."""
    expected_consensus_rate: int
    """Expected consensus reward rate. Expressed as percentage per year."""
    certificate_fee: int
    """Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately."""
    stress_test_fee_round: int
    """Amount charged per round of the stress test."""
    payment_asset: int
    """Payment method for the stress test and certificate fee."""
    max_test_duration: int
    """Maximum allowed duration for a stress test."""
    max_test_blocking: int
    """Maximum amount of rounds allowed to reserve for a stress test."""
    stake_min: int
    """Minimum stake allowed to be used for a stress test."""
    stake_max: int
    """Maximum stake allowed to be used for a stress test."""

    @staticmethod
    def method() -> str:
        return "cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class CertBoardOptinAsaArgs(_ArgsBase[None]):
    """Opts the platform address in to an ASA."""

    asa: int
    """Asset to opt into."""
    sender: str | bytes
    """Account to opt into the asa."""
    txn: TransactionWithSigner
    """Payment transaction to cover MBR increase."""

    @staticmethod
    def method() -> str:
        return "cert_board_optin_asa(asset,account,pay)void"


@dataclasses.dataclass(kw_only=True)
class CertBoardWithdrawArgs(_ArgsBase[None]):
    """Platform owner withdraws amount of asset from the platform."""

    amount: int
    """Amount to withdraw from the platform."""
    asset_id: int
    """ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO."""

    @staticmethod
    def method() -> str:
        return "cert_board_withdraw(uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class CertCreateArgs(_ArgsBase[None]):
    """An issuer creates a certificate stored on the platform."""

    recipient: str
    """Recipient of the certificate."""
    info: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    """Information to be recorded in the certificate."""
    mbr_txn: TransactionWithSigner
    """Payment transaction for the payment of the increase of platform MBR due to creation of the certificate."""
    txn: TransactionWithSigner
    """Transaction for the payment of the certificate issuance fee."""

    @staticmethod
    def method() -> str:
        return "cert_create(address,byte[1024],pay,txn)void"


@dataclasses.dataclass(kw_only=True)
class CertGetArgs(_ArgsBase[bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]]):
    """Returns the certificate issued by issuer to the recipient."""

    recipient: str
    """Recipient of the certificate."""
    issuer: str
    """Issuer of the certificate."""

    @staticmethod
    def method() -> str:
        return "cert_get(address,address)byte[1024]"


@dataclasses.dataclass(kw_only=True)
class StressCreateArgs(_ArgsBase[int]):
    """Creates a stress test."""

    stake: int
    """Amount of stake used in the stress test. The value is expressed in microALGO."""
    duration: int
    """Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing."""
    duration_max: int
    """Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created."""
    algo_txn: TransactionWithSigner
    """Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test."""
    txn: TransactionWithSigner
    """Transaction for the payment of the stress test fee."""

    @staticmethod
    def method() -> str:
        return "stress_create(uint64,uint64,uint64,pay,txn)uint64"


@dataclasses.dataclass(kw_only=True)
class StressEndArgs(_ArgsBase[None]):
    """Ends a stress test."""

    user_address: str
    """Address of the user that initiated the stress test."""
    stress_test_id: int
    """App ID of the stress test to end."""

    @staticmethod
    def method() -> str:
        return "stress_end(address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class StressTestInfo:
    avr_online_stake: int
    cnt_produced_block: int
    round_start: int
    round_end: int
    stake: int


@dataclasses.dataclass(kw_only=True)
class StressGetArgs(_ArgsBase[StressTestInfo]):
    """Gets information about a successfully finished stress test."""

    recipient: str
    """Recipient of the certificate."""
    stress_test_id: int
    """App ID of the stress test to end."""

    @staticmethod
    def method() -> str:
        return "stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class StressRecordArgs(_ArgsBase[None]):
    """Records a produced block of during the stress test."""

    user_address: str
    """Address of the user that initiated the stress test."""
    stress_test_id: int
    """App ID of the stress test to end."""

    @staticmethod
    def method() -> str:
        return "stress_record(address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class StressStartArgs(_ArgsBase[None]):
    """Starts a created test."""

    stress_test_id: int
    """App ID of the stress test to end."""
    key_reg_info: KeyRegTxnInfo
    mbr_txn: TransactionWithSigner
    """Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test."""

    @staticmethod
    def method() -> str:
        return "stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void"


@dataclasses.dataclass(kw_only=True)
class StressUnusedArgs(_ArgsBase[None]):
    """Ends a not used stress test."""

    user_address: str
    """Address of the user that initiated the stress test."""
    stress_test_id: int
    """App ID of the stress test to end."""

    @staticmethod
    def method() -> str:
        return "stress_unused(address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class CertBoardDeployArgs(_ArgsBase[int]):
    """Creates a new CertBoard."""

    @staticmethod
    def method() -> str:
        return "cert_board_deploy()uint64"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.blocked_algo = typing.cast(int, data.get(b"blocked_algo"))
        self.certificate_fee = typing.cast(int, data.get(b"certificate_fee"))
        self.expected_consensus_rate = typing.cast(int, data.get(b"expected_consensus_rate"))
        self.max_test_blocking = typing.cast(int, data.get(b"max_test_blocking"))
        self.max_test_duration = typing.cast(int, data.get(b"max_test_duration"))
        self.payment_asset = typing.cast(int, data.get(b"payment_asset"))
        self.pla_manager = ByteReader(typing.cast(bytes, data.get(b"pla_manager")))
        self.stake_max = typing.cast(int, data.get(b"stake_max"))
        self.stake_min = typing.cast(int, data.get(b"stake_min"))
        self.state = ByteReader(typing.cast(bytes, data.get(b"state")))
        self.stress_test_fee_round = typing.cast(int, data.get(b"stress_test_fee_round"))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def cert_board_key_reg(
        self,
        *,
        key_reg_info: KeyRegTxnInfo,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Issues a key (de)registration transaction by the platform.
        
        Adds a call to `cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param KeyRegTxnInfo key_reg_info: Key registration information to send.
        :param TransactionWithSigner txn: Payment transaction to cover costs for the key (de)registration fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertBoardKeyRegArgs(
            key_reg_info=key_reg_info,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def cert_board_set(
        self,
        *,
        pla_manager: str,
        expected_consensus_rate: int,
        certificate_fee: int,
        stress_test_fee_round: int,
        payment_asset: int,
        max_test_duration: int,
        max_test_blocking: int,
        stake_min: int,
        stake_max: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sets platform parameters (anew).
        
        Adds a call to `cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void` ABI method
        
        :param str pla_manager: Platform manager account.
        :param int expected_consensus_rate: Expected consensus reward rate. Expressed as percentage per year.
        :param int certificate_fee: Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately.
        :param int stress_test_fee_round: Amount charged per round of the stress test.
        :param int payment_asset: Payment method for the stress test and certificate fee.
        :param int max_test_duration: Maximum allowed duration for a stress test.
        :param int max_test_blocking: Maximum amount of rounds allowed to reserve for a stress test.
        :param int stake_min: Minimum stake allowed to be used for a stress test.
        :param int stake_max: Maximum stake allowed to be used for a stress test.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertBoardSetArgs(
            pla_manager=pla_manager,
            expected_consensus_rate=expected_consensus_rate,
            certificate_fee=certificate_fee,
            stress_test_fee_round=stress_test_fee_round,
            payment_asset=payment_asset,
            max_test_duration=max_test_duration,
            max_test_blocking=max_test_blocking,
            stake_min=stake_min,
            stake_max=stake_max,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def cert_board_optin_asa(
        self,
        *,
        asa: int,
        sender: str | bytes,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Opts the platform address in to an ASA.
        
        Adds a call to `cert_board_optin_asa(asset,account,pay)void` ABI method
        
        :param int asa: Asset to opt into.
        :param str | bytes sender: Account to opt into the asa.
        :param TransactionWithSigner txn: Payment transaction to cover MBR increase.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertBoardOptinAsaArgs(
            asa=asa,
            sender=sender,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def cert_board_withdraw(
        self,
        *,
        amount: int,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Platform owner withdraws amount of asset from the platform.
        
        Adds a call to `cert_board_withdraw(uint64,uint64)void` ABI method
        
        :param int amount: Amount to withdraw from the platform.
        :param int asset_id: ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertBoardWithdrawArgs(
            amount=amount,
            asset_id=asset_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def cert_create(
        self,
        *,
        recipient: str,
        info: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        mbr_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """An issuer creates a certificate stored on the platform.
        
        Adds a call to `cert_create(address,byte[1024],pay,txn)void` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] info: Information to be recorded in the certificate.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of platform MBR due to creation of the certificate.
        :param TransactionWithSigner txn: Transaction for the payment of the certificate issuance fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertCreateArgs(
            recipient=recipient,
            info=info,
            mbr_txn=mbr_txn,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def cert_get(
        self,
        *,
        recipient: str,
        issuer: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Returns the certificate issued by issuer to the recipient.
        
        Adds a call to `cert_get(address,address)byte[1024]` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param str issuer: Issuer of the certificate.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertGetArgs(
            recipient=recipient,
            issuer=issuer,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_create(
        self,
        *,
        stake: int,
        duration: int,
        duration_max: int,
        algo_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates a stress test.
        
        Adds a call to `stress_create(uint64,uint64,uint64,pay,txn)uint64` ABI method
        
        :param int stake: Amount of stake used in the stress test. The value is expressed in microALGO.
        :param int duration: Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
        :param int duration_max: Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created.
        :param TransactionWithSigner algo_txn: Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test.
        :param TransactionWithSigner txn: Transaction for the payment of the stress test fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressCreateArgs(
            stake=stake,
            duration=duration,
            duration_max=duration_max,
            algo_txn=algo_txn,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_end(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ends a stress test.
        
        Adds a call to `stress_end(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressEndArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_get(
        self,
        *,
        recipient: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Gets information about a successfully finished stress test.
        
        Adds a call to `stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressGetArgs(
            recipient=recipient,
            stress_test_id=stress_test_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_record(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Records a produced block of during the stress test.
        
        Adds a call to `stress_record(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressRecordArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_start(
        self,
        *,
        stress_test_id: int,
        key_reg_info: KeyRegTxnInfo,
        mbr_txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Starts a created test.
        
        Adds a call to `stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param int stress_test_id: App ID of the stress test to end.
        :param KeyRegTxnInfo key_reg_info: The `key_reg_info` ABI parameter
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressStartArgs(
            stress_test_id=stress_test_id,
            key_reg_info=key_reg_info,
            mbr_txn=mbr_txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stress_unused(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ends a not used stress test.
        
        Adds a call to `stress_unused(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StressUnusedArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_cert_board_deploy(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Creates a new CertBoard.
        
        Adds a call to `cert_board_deploy()uint64` ABI method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CertBoardDeployArgs()
        self.app_client.compose_create(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class CertBoardClient:
    """
        Certification Board servers as decentralized registrar for certificates to build trust in
        the node running capabilities of an entity.
        It supports issuing of attestations according to applicable node running standards by any entity.
        Moreover, it supports generation of on-chain produced proofs of an entity's node running
        capabilities through self-initiated stress tests, which get recorded as another certificate type.
    
        Global state
        ------------
    
        pla_manager : Account
            Platform manager account.
    
        expected_consensus_rate : UInt64
            Expected consensus reward rate.
            Expressed as percentage per year.
    
        certificate_fee : UInt64
            Fee charged by the platform for issuing of a certificate by anyone.
            Note: MBR increase is paid separately.
        stress_test_fee_round : UInt64
            Amount charged per round of the stress test.
        payment_asset : UInt64
            Payment method for the stress test and certificate fee.
    
        max_test_duration : UInt64
            Maximum allowed duration for a stress test.
        max_test_blocking : UInt64
            Maximum amount of rounds allowed to reserve for a stress test.
    
        stake_min : UInt64
            Minimum stake allowed to be used for a stress test.
        stake_max : UInt64
            Maximum stake allowed to be used for a stress test.
    
        blocked_algo: UInt64
            Amount of ALGO currently blocked and awaiting to be used in started stress test(s) requests.
    
        state : Bytes
            State of the contract. Can be one of the following:
                DEPLOYED - CertBoard has been created.
                LIVE - CertBoard is live.
    
        Methods
        -------
        cert_board_deploy(
        ) -> arc4.UInt64:
            Creates a new CertBoard.
    
        cert_board_key_reg(
            key_reg_info: KeyRegTxnInfo,
            txn: gtxn.PaymentTransaction,
        ) -> None:
            Issues a key (de)registration transaction by the platform.
    
        cert_board_set(
            pla_manager: arc4.Address,
            expected_consensus_rate: UInt64,
            certificate_fee: UInt64,
            stress_test_fee_round: UInt64,
            payment_asset: UInt64,
            max_test_duration: UInt64,
            max_test_blocking: UInt64,
            stake_min: UInt64,
            stake_max: UInt64,
        ) -> None:
            Sets platform parameters (anew).
    
        cert_board_optin_asa(
            asa: Asset,
            sender: Account,
            txn: gtxn.PaymentTransaction,
        ) -> None:
            Opts the platform address in to an ASA.
    
        cert_board_withdraw(
            amount: UInt64,
            asset_id: UInt64,
        ) -> None:
            Platform owner withdraws amount of asset from the platform.
    
        cert_create(
            recipient: arc4.Address,
            info: CertInfo,
            mbr_txn: gtxn.PaymentTransaction,
            txn: gtxn.Transaction,
        ) -> None:
            An issuer creates a certificate stored on the platform.
    
        cert_get(
            recipient: arc4.Address,
            issuer: arc4.Address,
        ) -> CertInfo:
            Returns the certificate issued by issuer to the recipient.
    
        stress_create(
            stake: UInt64,
            duration: UInt64,
            round_end_max: UInt64,
            algo_txn: gtxn.PaymentTransaction,
            txn: gtxn.Transaction,
        ) -> arc4.UInt64:
            Creates a stress test.
    
        stress_end(
            user_address: arc4.Address,
            stress_test_id: UInt64,
        ) -> None:
            Ends a stress test.
    
        stress_get(
            recipient: arc4.Address,
            stress_test_id: UInt64,
        ) -> StressTestInfo:
            Gets information about a successfully finished stress test.
    
        stress_record(
            user_address: arc4.Address,
            stress_test_id: UInt64,
        ) -> None:
            Records a produced block of during the stress test.
    
        stress_start(
            stress_test_id: UInt64,
            key_reg_info: KeyRegTxnInfo,
        ) -> None:
            Starts a created test.
    
        stress_unused(
            user_address: arc4.Address,
            stress_test_id: UInt64,
        ) -> None:
            Ends a not used stress test.
    
        
    
    A class for interacting with the CertBoard app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        CertBoardClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def cert_board_key_reg(
        self,
        *,
        key_reg_info: KeyRegTxnInfo,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Issues a key (de)registration transaction by the platform.
        
        Calls `cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param KeyRegTxnInfo key_reg_info: Key registration information to send.
        :param TransactionWithSigner txn: Payment transaction to cover costs for the key (de)registration fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CertBoardKeyRegArgs(
            key_reg_info=key_reg_info,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def cert_board_set(
        self,
        *,
        pla_manager: str,
        expected_consensus_rate: int,
        certificate_fee: int,
        stress_test_fee_round: int,
        payment_asset: int,
        max_test_duration: int,
        max_test_blocking: int,
        stake_min: int,
        stake_max: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sets platform parameters (anew).
        
        Calls `cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void` ABI method
        
        :param str pla_manager: Platform manager account.
        :param int expected_consensus_rate: Expected consensus reward rate. Expressed as percentage per year.
        :param int certificate_fee: Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately.
        :param int stress_test_fee_round: Amount charged per round of the stress test.
        :param int payment_asset: Payment method for the stress test and certificate fee.
        :param int max_test_duration: Maximum allowed duration for a stress test.
        :param int max_test_blocking: Maximum amount of rounds allowed to reserve for a stress test.
        :param int stake_min: Minimum stake allowed to be used for a stress test.
        :param int stake_max: Maximum stake allowed to be used for a stress test.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CertBoardSetArgs(
            pla_manager=pla_manager,
            expected_consensus_rate=expected_consensus_rate,
            certificate_fee=certificate_fee,
            stress_test_fee_round=stress_test_fee_round,
            payment_asset=payment_asset,
            max_test_duration=max_test_duration,
            max_test_blocking=max_test_blocking,
            stake_min=stake_min,
            stake_max=stake_max,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def cert_board_optin_asa(
        self,
        *,
        asa: int,
        sender: str | bytes,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Opts the platform address in to an ASA.
        
        Calls `cert_board_optin_asa(asset,account,pay)void` ABI method
        
        :param int asa: Asset to opt into.
        :param str | bytes sender: Account to opt into the asa.
        :param TransactionWithSigner txn: Payment transaction to cover MBR increase.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CertBoardOptinAsaArgs(
            asa=asa,
            sender=sender,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def cert_board_withdraw(
        self,
        *,
        amount: int,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Platform owner withdraws amount of asset from the platform.
        
        Calls `cert_board_withdraw(uint64,uint64)void` ABI method
        
        :param int amount: Amount to withdraw from the platform.
        :param int asset_id: ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CertBoardWithdrawArgs(
            amount=amount,
            asset_id=asset_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def cert_create(
        self,
        *,
        recipient: str,
        info: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        mbr_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """An issuer creates a certificate stored on the platform.
        
        Calls `cert_create(address,byte[1024],pay,txn)void` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] info: Information to be recorded in the certificate.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of platform MBR due to creation of the certificate.
        :param TransactionWithSigner txn: Transaction for the payment of the certificate issuance fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CertCreateArgs(
            recipient=recipient,
            info=info,
            mbr_txn=mbr_txn,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def cert_get(
        self,
        *,
        recipient: str,
        issuer: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]]:
        """Returns the certificate issued by issuer to the recipient.
        
        Calls `cert_get(address,address)byte[1024]` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param str issuer: Issuer of the certificate.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]]: The result of the transaction"""

        args = CertGetArgs(
            recipient=recipient,
            issuer=issuer,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stress_create(
        self,
        *,
        stake: int,
        duration: int,
        duration_max: int,
        algo_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a stress test.
        
        Calls `stress_create(uint64,uint64,uint64,pay,txn)uint64` ABI method
        
        :param int stake: Amount of stake used in the stress test. The value is expressed in microALGO.
        :param int duration: Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
        :param int duration_max: Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created.
        :param TransactionWithSigner algo_txn: Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test.
        :param TransactionWithSigner txn: Transaction for the payment of the stress test fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = StressCreateArgs(
            stake=stake,
            duration=duration,
            duration_max=duration_max,
            algo_txn=algo_txn,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stress_end(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Ends a stress test.
        
        Calls `stress_end(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = StressEndArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stress_get(
        self,
        *,
        recipient: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[StressTestInfo]:
        """Gets information about a successfully finished stress test.
        
        Calls `stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method
        
        :param str recipient: Recipient of the certificate.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[StressTestInfo]: The result of the transaction"""

        args = StressGetArgs(
            recipient=recipient,
            stress_test_id=stress_test_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = StressTestInfo(**result_dict)
        return result

    def stress_record(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Records a produced block of during the stress test.
        
        Calls `stress_record(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = StressRecordArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stress_start(
        self,
        *,
        stress_test_id: int,
        key_reg_info: KeyRegTxnInfo,
        mbr_txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Starts a created test.
        
        Calls `stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void` ABI method
        
        :param int stress_test_id: App ID of the stress test to end.
        :param KeyRegTxnInfo key_reg_info: The `key_reg_info` ABI parameter
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = StressStartArgs(
            stress_test_id=stress_test_id,
            key_reg_info=key_reg_info,
            mbr_txn=mbr_txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stress_unused(
        self,
        *,
        user_address: str,
        stress_test_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Ends a not used stress test.
        
        Calls `stress_unused(address,uint64)void` ABI method
        
        :param str user_address: Address of the user that initiated the stress test.
        :param int stress_test_id: App ID of the stress test to end.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = StressUnusedArgs(
            user_address=user_address,
            stress_test_id=stress_test_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_cert_board_deploy(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a new CertBoard.
        
        Calls `cert_board_deploy()uint64` ABI method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: App ID of the created application."""

        args = CertBoardDeployArgs()
        result = self.app_client.create(
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: DeployCreate[CertBoardDeployArgs],
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: algokit_utils.DeployCallArgs | None = None,
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param DeployCreate[CertBoardDeployArgs] create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param algokit_utils.DeployCallArgs | None delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
