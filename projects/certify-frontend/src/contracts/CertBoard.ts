/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "cert_board_deploy()uint64": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "key_reg_info": {
          "name": "KeyRegTxnInfo",
          "elements": [
            [
              "vote_first",
              "uint64"
            ],
            [
              "vote_last",
              "uint64"
            ],
            [
              "vote_key_dilution",
              "uint64"
            ],
            [
              "vote_pk",
              "byte[32]"
            ],
            [
              "selection_pk",
              "byte[32]"
            ],
            [
              "state_proof_pk",
              "byte[64]"
            ],
            [
              "sender",
              "address"
            ]
          ]
        }
      }
    },
    "cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "cert_board_optin_asa(asset,account,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "cert_board_withdraw(uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "cert_create(address,byte[1024],pay,txn)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "cert_get(address,address)byte[1024]": {
      "read_only": true,
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stress_create(uint64,uint64,uint64,pay,txn)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stress_end(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)": {
      "read_only": true,
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "StressTestInfo",
          "elements": [
            [
              "avr_online_stake",
              "uint64"
            ],
            [
              "cnt_produced_block",
              "uint64"
            ],
            [
              "round_start",
              "uint64"
            ],
            [
              "round_end",
              "uint64"
            ],
            [
              "stake",
              "uint64"
            ]
          ]
        }
      }
    },
    "stress_record(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "key_reg_info": {
          "name": "KeyRegTxnInfo",
          "elements": [
            [
              "vote_first",
              "uint64"
            ],
            [
              "vote_last",
              "uint64"
            ],
            [
              "vote_key_dilution",
              "uint64"
            ],
            [
              "vote_pk",
              "byte[32]"
            ],
            [
              "selection_pk",
              "byte[32]"
            ],
            [
              "state_proof_pk",
              "byte[64]"
            ],
            [
              "sender",
              "address"
            ]
          ]
        }
      }
    },
    "stress_unused(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgY2FsbHN1YiBfX3B1eWFfYXJjNF9yb3V0ZXJfXwogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLl9fcHV5YV9hcmM0X3JvdXRlcl9fKCkgLT4gdWludDY0OgpfX3B1eWFfYXJjNF9yb3V0ZXJfXzoKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMTgKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9kZXBsb3koKXVpbnQ2NCIKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9rZXlfcmVnKCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSxwYXkpdm9pZCIKICAgIG1ldGhvZCAiY2VydF9ib2FyZF9zZXQoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICBtZXRob2QgImNlcnRfYm9hcmRfb3B0aW5fYXNhKGFzc2V0LGFjY291bnQscGF5KXZvaWQiCiAgICBtZXRob2QgImNlcnRfYm9hcmRfd2l0aGRyYXcodWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJjZXJ0X2NyZWF0ZShhZGRyZXNzLGJ5dGVbMTAyNF0scGF5LHR4bil2b2lkIgogICAgbWV0aG9kICJjZXJ0X2dldChhZGRyZXNzLGFkZHJlc3MpYnl0ZVsxMDI0XSIKICAgIG1ldGhvZCAic3RyZXNzX2NyZWF0ZSh1aW50NjQsdWludDY0LHVpbnQ2NCxwYXksdHhuKXVpbnQ2NCIKICAgIG1ldGhvZCAic3RyZXNzX2VuZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzdHJlc3NfZ2V0KGFkZHJlc3MsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIG1ldGhvZCAic3RyZXNzX3JlY29yZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzdHJlc3Nfc3RhcnQodWludDY0LCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSxwYXkpdm9pZCIKICAgIG1ldGhvZCAic3RyZXNzX3VudXNlZChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF9kZXBsb3lfcm91dGVAMiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2JvYXJkX2tleV9yZWdfcm91dGVAMyBfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2JvYXJkX3NldF9yb3V0ZUA0IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfb3B0aW5fYXNhX3JvdXRlQDUgX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF93aXRoZHJhd19yb3V0ZUA2IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfY3JlYXRlX3JvdXRlQDcgX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9nZXRfcm91dGVAOCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19zdHJlc3NfY3JlYXRlX3JvdXRlQDkgX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2VuZF9yb3V0ZUAxMCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19zdHJlc3NfZ2V0X3JvdXRlQDExIF9fcHV5YV9hcmM0X3JvdXRlcl9fX3N0cmVzc19yZWNvcmRfcm91dGVAMTIgX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3N0YXJ0X3JvdXRlQDEzIF9fcHV5YV9hcmM0X3JvdXRlcl9fX3N0cmVzc191bnVzZWRfcm91dGVAMTQKICAgIGludCAwCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfZGVwbG95X3JvdXRlQDI6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gaXMgY3JlYXRpbmcKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9kZXBsb3kKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfa2V5X3JlZ19yb3V0ZUAzOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICBjYWxsc3ViIGNlcnRfYm9hcmRfa2V5X3JlZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9ib2FyZF9zZXRfcm91dGVANDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGJ0b2kKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9zZXQKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfb3B0aW5fYXNhX3JvdXRlQDU6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBc3NldHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIGNhbGxzdWIgY2VydF9ib2FyZF9vcHRpbl9hc2EKICAgIGludCAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NlcnRfYm9hcmRfd2l0aGRyYXdfcm91dGVANjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgY2VydF9ib2FyZF93aXRoZHJhdwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY2VydF9jcmVhdGVfcm91dGVANzoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBjYWxsc3ViIGNlcnRfY3JlYXRlCiAgICBpbnQgMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jZXJ0X2dldF9yb3V0ZUA4OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgY2FsbHN1YiBjZXJ0X2dldAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2NyZWF0ZV9yb3V0ZUA5OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGNhbGxzdWIgc3RyZXNzX2NyZWF0ZQogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2VuZF9yb3V0ZUAxMDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX2VuZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX2dldF9yb3V0ZUAxMToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX2dldAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3JlY29yZF9yb3V0ZUAxMjoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX3JlY29yZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3N0YXJ0X3JvdXRlQDEzOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICBjYWxsc3ViIHN0cmVzc19zdGFydAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fc3RyZXNzX3VudXNlZF9yb3V0ZUAxNDoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGNhbGxzdWIgc3RyZXNzX3VudXNlZAogICAgaW50IDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYWZ0ZXJfaWZfZWxzZUAxODoKICAgIGludCAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9ib2FyZF9kZXBsb3koKSAtPiBieXRlczoKY2VydF9ib2FyZF9kZXBsb3k6CiAgICBwcm90byAwIDEKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3RhdGUiCiAgICBieXRlIDB4MDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2JvYXJkX2tleV9yZWcoa2V5X3JlZ19pbmZvOiBieXRlcywgdHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNlcnRfYm9hcmRfa2V5X3JlZzoKICAgIHByb3RvIDIgMAogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsYV9tYW5hZ2VyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgcGxhdGZvcm0gbWFuYWdlci4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAxNiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDg4IDY0IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDE1MiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIFN0YXRlUHJvb2ZQSwogICAgaXR4bl9maWVsZCBWb3RlS2V5RGlsdXRpb24KICAgIGl0eG5fZmllbGQgVm90ZUxhc3QKICAgIGl0eG5fZmllbGQgVm90ZUZpcnN0CiAgICBpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCiAgICBpdHhuX2ZpZWxkIFZvdGVQSwogICAgaW50IGtleXJlZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9ib2FyZF9zZXQocGxhX21hbmFnZXI6IGJ5dGVzLCBleHBlY3RlZF9jb25zZW5zdXNfcmF0ZTogdWludDY0LCBjZXJ0aWZpY2F0ZV9mZWU6IHVpbnQ2NCwgc3RyZXNzX3Rlc3RfZmVlX3JvdW5kOiB1aW50NjQsIHBheW1lbnRfYXNzZXQ6IHVpbnQ2NCwgbWF4X3Rlc3RfZHVyYXRpb246IHVpbnQ2NCwgbWF4X3Rlc3RfYmxvY2tpbmc6IHVpbnQ2NCwgc3Rha2VfbWluOiB1aW50NjQsIHN0YWtlX21heDogdWludDY0KSAtPiB2b2lkOgpjZXJ0X2JvYXJkX3NldDoKICAgIHByb3RvIDkgMAogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsYV9tYW5hZ2VyIGV4aXN0cwogICAgPT0KICAgIGJueiBjZXJ0X2JvYXJkX3NldF9ib29sX3RydWVAMgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYnogY2VydF9ib2FyZF9zZXRfYm9vbF9mYWxzZUAzCgpjZXJ0X2JvYXJkX3NldF9ib29sX3RydWVAMjoKICAgIGludCAxCiAgICBiIGNlcnRfYm9hcmRfc2V0X2Jvb2xfbWVyZ2VANAoKY2VydF9ib2FyZF9zZXRfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCmNlcnRfYm9hcmRfc2V0X2Jvb2xfbWVyZ2VANDoKICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgcGxhdGZvcm0gbWFuYWdlciBvciBjcmVhdG9yLgogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBmcmFtZV9kaWcgLTkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJleHBlY3RlZF9jb25zZW5zdXNfcmF0ZSIKICAgIGZyYW1lX2RpZyAtOAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGZyYW1lX2RpZyAtNwogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0cmVzc190ZXN0X2ZlZV9yb3VuZCIKICAgIGZyYW1lX2RpZyAtNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJtYXhfdGVzdF9kdXJhdGlvbiIKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgIm1heF90ZXN0X2Jsb2NraW5nIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWluIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgaW50IDAKICAgIGJ5dGUgInN0YWtlX21pbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGFrZV9taW4gZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YWtlX21heCBleGlzdHMKICAgIDwKICAgIGFzc2VydCAvLyBNYXggc3Rha2UgbXVzdCBiZSBsYXJnZXIgdGhhbiBtaW4uCiAgICBpbnQgMAogICAgYnl0ZSAibWF4X3Rlc3RfZHVyYXRpb24iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWF4X3Rlc3RfZHVyYXRpb24gZXhpc3RzCiAgICBpbnQgMAogICAgYnl0ZSAibWF4X3Rlc3RfYmxvY2tpbmciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWF4X3Rlc3RfYmxvY2tpbmcgZXhpc3RzCiAgICA8CiAgICBhc3NlcnQgLy8gTWF4IGR1cmF0aW9uIG11c3QgYmUgc21hbGxlciB0aGFuIG1heCByZXF1ZXN0cyBibG9jayByb3VuZHMuCiAgICBmcmFtZV9kaWcgLTUKICAgIGJ6IGNlcnRfYm9hcmRfc2V0X2FmdGVyX2lmX2Vsc2VANgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtNQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBOb3Qgb3B0ZWQgaW50byBhc3NldC4KCmNlcnRfYm9hcmRfc2V0X2FmdGVyX2lmX2Vsc2VANjoKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLmNlcnRfYm9hcmRfb3B0aW5fYXNhKGFzYTogdWludDY0LCBzZW5kZXI6IGJ5dGVzLCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKY2VydF9ib2FyZF9vcHRpbl9hc2E6CiAgICBwcm90byAzIDAKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJwbGFfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wbGFfbWFuYWdlciBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHBsYXRmb3JtIG1hbmFnZXIuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIE1CUiBpbmNyZWFzZSBmb3Igb3B0aW5nIGludG8gYW4gQVNBLgogICAgaXR4bl9iZWdpbgogICAgaW50IDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnQgYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2JvYXJkX3dpdGhkcmF3KGFtb3VudDogdWludDY0LCBhc3NldF9pZDogdWludDY0KSAtPiB2b2lkOgpjZXJ0X2JvYXJkX3dpdGhkcmF3OgogICAgcHJvdG8gMiAwCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBwbGF0Zm9ybSBtYW5hZ2VyLgogICAgZnJhbWVfZGlnIC0xCiAgICBieiBjZXJ0X2JvYXJkX3dpdGhkcmF3X2Vsc2VfYm9keUAzCiAgICBpdHhuX2JlZ2luCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgaW50IGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIGNlcnRfYm9hcmRfd2l0aGRyYXdfYWZ0ZXJfaWZfZWxzZUA1CgpjZXJ0X2JvYXJkX3dpdGhkcmF3X2Vsc2VfYm9keUAzOgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYmxvY2tlZF9hbGdvIGV4aXN0cwogICAgLQogICAgZnJhbWVfZGlnIC0yCiAgICA+PQogICAgYXNzZXJ0IC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggYXZhaWxhYmxlIEFMR08gZm9yIHdpdGhkcmF3YWwuCiAgICBpdHhuX2JlZ2luCiAgICBpbnQgMAogICAgYnl0ZSAicGxhX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxhX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpbnQgcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpjZXJ0X2JvYXJkX3dpdGhkcmF3X2FmdGVyX2lmX2Vsc2VANToKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5jZXJ0X2NyZWF0ZShyZWNpcGllbnQ6IGJ5dGVzLCBpbmZvOiBieXRlcywgbWJyX3R4bjogdWludDY0LCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKY2VydF9jcmVhdGU6CiAgICBwcm90byA0IDAKICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBmcmFtZV9kaWcgLTQKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBib3hfcHV0CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIC0KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludCBwYXkKICAgID09CiAgICBieiBjZXJ0X2NyZWF0ZV9lbHNlX2JvZHlAMgogICAgaW50IDAKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGF5bWVudF9hc3NldCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jZXJ0aWZpY2F0ZV9mZWUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIGNlcnRfY3JlYXRlX2FmdGVyX2lmX2Vsc2VANgoKY2VydF9jcmVhdGVfZWxzZV9ib2R5QDI6CiAgICBmcmFtZV9kaWcgMAogICAgaW50IGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIHR5cGUgbXVzdCBiZSBlaXRoZXIgUGF5bWVudCBvciBBc3NldFRyYW5zZmVyLgogICAgaW50IDAKICAgIGJ5dGUgInBheW1lbnRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGF5bWVudF9hc3NldCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgWGZlckFzc2V0CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldEFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jZXJ0aWZpY2F0ZV9mZWUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCgpjZXJ0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDY6CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2VydF9nZXQocmVjaXBpZW50OiBieXRlcywgaXNzdWVyOiBieXRlcykgLT4gYnl0ZXM6CmNlcnRfZ2V0OgogICAgcHJvdG8gMiAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBCb3ggZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuc3RyZXNzX2NyZWF0ZShzdGFrZTogdWludDY0LCBkdXJhdGlvbjogdWludDY0LCBkdXJhdGlvbl9tYXg6IHVpbnQ2NCwgYWxnb190eG46IHVpbnQ2NCwgdHhuOiB1aW50NjQpIC0+IGJ5dGVzOgpzdHJlc3NfY3JlYXRlOgogICAgcHJvdG8gNSAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGludCAwCiAgICBieXRlICJzdGFrZV9tYXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2VfbWF4IGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICA+CiAgICBhc3NlcnQgLy8gUmVxdWVzdGVkIHN0YWtlIGZvciB0aGUgc3RyZXNzIHRlc3QgaXMgbGFyZ2VyIHRoYW4gYWxsb3dlZC4KICAgIGludCAwCiAgICBieXRlICJzdGFrZV9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3Rha2VfbWluIGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICA8CiAgICBhc3NlcnQgLy8gUmVxdWVzdGVkIHN0YWtlIGZvciB0aGUgc3RyZXNzIHRlc3QgaXMgc21hbGxlciB0aGFuIGFsbG93ZWQuCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHR4biBTZW5kZXIKICAgIGl0eG5fYmVnaW4KICAgIGludCAwCiAgICBieXRlICJwbGFfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wbGFfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtNQogICAgaXRvYgogICAgZnJhbWVfZGlnIC00CiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIGludCAxMgogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1VaW50CiAgICBpbnQgMwogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIGJ5dGUgYmFzZTY0IENvRUJRdz09CiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIGJ5dGUgYmFzZTY0IENpQUVBQUVGcXIyREZDWVRDM0p2ZFc1a1gyVnVaR1ZrQlhOMFlYUmxDWEp2ZFc1a1gyVnVaQWhrZFhKaGRHbHZiZ1Z6ZEdGclpSTmpiblJmY0hKdlpIVmpaV1JmWW14dlkydHpEM1J2ZEdGc1gzTjBZV3RsWDNOMWJSTmpiblJmZEc5MFlXeGZjM1JoYTJWZmMzVnREWEp2ZFc1a1gyVnVaRjl0WVhnTWRYTmxjbDloWkdSeVpYTnpER1IxY21GMGFXOXVYMjFoZUExeWIzVnVaRjlqY21WaGRHVmtDM0p2ZFc1a1gzTjBZWEowQ214aGMzUmZZbXh2WTJzRUZSOThkUTF2ZDI1bGNsOWhaR1J5WlhOekFRRUJBZ0VBTVJoQUFBT0lBdDJJQUFGRGlnQUJNUnRCQUorQ0JRUnFwdm1JQkYzeW9Cd0VybU5DQkFTR0pxWVdCSFd4M1VBMkdnQ09CUUFDQUNZQVFnQlhBR01paVRFWkZFUXhHQlJFTmhvQk5ob0NOaG9ERnpZYUJCYzJHZ1VYaUFCWUp3NU1VTEFqaVRFWkZFUXhHRVEyR2dFMkdnSXhGaU1KU1RnUUl4SkVpQUNUSTRreEdTUVNSREVZUkRZYUFZZ0JOaWNPVEZDd0k0a3hHUlJFTVJoRWlBSENJNGt4R1NRU1JERVlSSWdDQVNjT1RGQ3dJNGtpaVlvRkFTY0ppL3RuSncrTC9HY25CSXY5Wnl1TC9tY25Db3YvWnlpQmdNTFhMMmNuQlNKbkp3WWxaeWNISTJjcEp4Qm5Kd3N5Qm1jaUp3dGxSQ0luQ21WRUNDY0lUR2NpSzJWRUlpY0taVVFNUkNJclpVUWpEVVF5Q0JhSmlnTUFNUUF5Q1JKRUlpbGxSQ2NRRWtRaUp3bGxSSXY5RWtReUJpSXJaVVFJS2t4bklpcGxSQ0luQ0dWRURFU0wvemdITWdvU1JDSW5CR1ZFaS84NENCSkVNZ1lqQ0NjTVRHY2lKd3hsUkNjTlRHZUwvbGNBQ0JjaUp3dGxSRXNCRWtTTC9sY0lDQmNpSndobFJFc0JFa1NML2xlWUlFa3lDaEpFc1l2K1Z4Z2dUSXYrVnpnZ2kvNVhFQWdYaS81WFdFQlBBN0lBc2oreURrOENzZzFQQXJJTXNndXlDb0VDc2hBaXNnR3pLU2NSWjRtS0FRRXhBRElKRWtRaUtXVkVKeEVTUkNneUJtY2lKdzlsUkl2L0VrRUFGQ0lvWlVRaUttVkVERUVBQkNKQ0FCQWpRZ0FNSWlobFJDSXFaVVFNRkVRanNUSUpTYklKSXJJSXNnY2pzaEFpc2dHeklpY0daVVFpSndkbFJBb25FaUpQQTFSTUZpSW5CV1ZFRmlJbkRHVkVGaUlxWlVRV0lpaGxSQllpSndSbFJCWWlKd2xsUkU4SFR3ZFFUd1pRVHdWUVR3UlFUd05RVHdKUVRGQ0ppZ0FBSWlsbFJDY1JFa1F5QmlJb1pVUU1SRElHSWlwbFJFc0JEVVFpSncxbFJFc0JERVFpSndWbFJDTUlKd1ZNWnljTlRHY2lKd1psUkNVSUp3Wk1aeUluQjJWRUl3Z25CMHhuaVlvQUFURUFNZ2tTUkNJcFpVUW5FQkpFTWdZaUsyVkVDQ0luQ0dWRURVU3hNZ2xKc2draXNnaXlCeU95RUNLeUFiTWlKd1JsUkJhSmlnQUFKd2t5QTJjbkR6SURaeWNFSW1jckltY25DaUpuSndzaVp5Y01JbWNxSW1jb0ltY25DQ0puSncwaVp5Y0ZJbWNuQmlKbkp3Y2paeWtuRW1lSgogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgbWV0aG9kICJjcmVhdGUoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIGludCAwCiAgICBieXRlICJzdHJlc3NfdGVzdF9mZWVfcm91bmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RyZXNzX3Rlc3RfZmVlX3JvdW5kIGV4aXN0cwogICAgZnJhbWVfZGlnIC0zCiAgICAqCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludCBwYXkKICAgID09CiAgICBieiBzdHJlc3NfY3JlYXRlX2Vsc2VfYm9keUAzCiAgICBpbnQgMAogICAgYnl0ZSAicGF5bWVudF9hc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wYXltZW50X2Fzc2V0IGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIHN0cmVzc19jcmVhdGVfYWZ0ZXJfaWZfZWxzZUA3CgpzdHJlc3NfY3JlYXRlX2Vsc2VfYm9keUAzOgogICAgZnJhbWVfZGlnIDIKICAgIGludCBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiB0eXBlIG11c3QgYmUgZWl0aGVyIFBheW1lbnQgb3IgQXNzZXRUcmFuc2Zlci4KICAgIGludCAwCiAgICBieXRlICJwYXltZW50X2Fzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBheW1lbnRfYXNzZXQgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFhmZXJBc3NldAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgID09CiAgICBhc3NlcnQgLy8gU2VudCBhbW91bnQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KCnN0cmVzc19jcmVhdGVfYWZ0ZXJfaWZfZWxzZUA3OgogICAgaW50IDAKICAgIGJ5dGUgImV4cGVjdGVkX2NvbnNlbnN1c19yYXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmV4cGVjdGVkX2NvbnNlbnN1c19yYXRlIGV4aXN0cwogICAgZnJhbWVfZGlnIC01CiAgICAqCiAgICBmcmFtZV9kaWcgLTMKICAgICoKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgZnJhbWVfZGlnIDAKICAgIC0KICAgIGRpZyAxCiAgICArCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgPAogICAgYXNzZXJ0CiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbGdvIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJsb2NrZWRfYWxnbyBleGlzdHMKICAgIGZyYW1lX2RpZyAtNQogICAgdW5jb3ZlciAyCiAgICArCiAgICArCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc19lbmQodXNlcl9hZGRyZXNzOiBieXRlcywgc3RyZXNzX3Rlc3RfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc3RyZXNzX2VuZDoKICAgIHByb3RvIDIgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFVzZXIgYWRkcmVzcyBhbmQgc3RyZXNzIHRlc3QgSUQgY29tYmluYXRpb24gYXJlIG5vdCBmb3VuZCBhdCB0aGUgcGxhdGZvcm0uCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdHJlc3NfdGVzdHMgZW50cnkgZXhpc3RzCiAgICBjYWxsc3ViIF9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0CiAgICA9PQogICAgYXNzZXJ0IC8vIFN0cmVzcyB0ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkLgogICAgaXR4bl9iZWdpbgogICAgdHhuIFNlbmRlcgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAiZW5kKGFkZHJlc3MpKGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBkaWcgMQogICAgZXh0cmFjdCA0MSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBjb3ZlciA0CiAgICBidG9pCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgaW50IDAKICAgIGdldGJpdAogICAgYnl0ZSAweDAwCiAgICBpbnQgMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGUgMHgwMAogICAgIT0KICAgIGJ6IHN0cmVzc19lbmRfZWxzZV9ib2R5QDMKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGV4dHJhY3QgMSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgc3dhcAogICAgZHVwCiAgICBleHRyYWN0IDkgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIGR1cAogICAgZXh0cmFjdCAxNyA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgY292ZXIgMgogICAgZXh0cmFjdCAyNSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgMQogICAgY29uY2F0CiAgICBib3hfcHV0CiAgICBiIHN0cmVzc19lbmRfYWZ0ZXJfaWZfZWxzZUA0CgpzdHJlc3NfZW5kX2Vsc2VfYm9keUAzOgogICAgYm94X2RlbAogICAgYXNzZXJ0CgpzdHJlc3NfZW5kX2FmdGVyX2lmX2Vsc2VANDoKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0Ll9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0KCkgLT4gYnl0ZXM6Cl9nZXRfc3RyZXNzX3Rlc3RfaW5mb19pbml0OgogICAgcHJvdG8gMCAxCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5zdHJlc3NfZ2V0KHJlY2lwaWVudDogYnl0ZXMsIHN0cmVzc190ZXN0X2lkOiB1aW50NjQpIC0+IGJ5dGVzOgpzdHJlc3NfZ2V0OgogICAgcHJvdG8gMiAxCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0cmVzc190ZXN0cyBlbnRyeSBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0X2JvYXJkLmNvbnRyYWN0LkNlcnRCb2FyZC5zdHJlc3NfcmVjb3JkKHVzZXJfYWRkcmVzczogYnl0ZXMsIHN0cmVzc190ZXN0X2lkOiB1aW50NjQpIC0+IHZvaWQ6CnN0cmVzc19yZWNvcmQ6CiAgICBwcm90byAyIDAKICAgIGludCAwCiAgICBieXRlICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGUgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBVc2VyIGFkZHJlc3MgYW5kIHN0cmVzcyB0ZXN0IElEIGNvbWJpbmF0aW9uIGFyZSBub3QgZm91bmQgYXQgdGhlIHBsYXRmb3JtLgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RyZXNzX3Rlc3RzIGVudHJ5IGV4aXN0cwogICAgY2FsbHN1YiBfZ2V0X3N0cmVzc190ZXN0X2luZm9faW5pdAogICAgPT0KICAgIGFzc2VydCAvLyBTdHJlc3MgdGVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZC4KICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInJlY29yZCgpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc19zdGFydChzdHJlc3NfdGVzdF9pZDogdWludDY0LCBrZXlfcmVnX2luZm86IGJ5dGVzLCBtYnJfdHhuOiB1aW50NjQpIC0+IHZvaWQ6CnN0cmVzc19zdGFydDoKICAgIHByb3RvIDMgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMwogICAgYnl0ZSAweDc1NzM2NTcyNWY2MTY0NjQ3MjY1NzM3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydAogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgZGlnIDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY2FsbHN1YiBfZ2V0X3N0cmVzc190ZXN0X2luZm9faW5pdAogICAgYm94X3B1dAogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlIDB4NzM3NDYxNmI2NQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydAogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX25leHQKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInN0YXJ0KGFkZHJlc3MsKHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLGFkZHJlc3MpLHBheSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBzd2FwCiAgICAtCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLnN0cmVzc191bnVzZWQodXNlcl9hZGRyZXNzOiBieXRlcywgc3RyZXNzX3Rlc3RfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc3RyZXNzX3VudXNlZDoKICAgIHByb3RvIDIgMAogICAgaW50IDAKICAgIGJ5dGUgInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZSAweDAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9idXJ5IC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgMHg3NTczNjU3MjVmNjE2NDY0NzI2NTczNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQKICAgIGZyYW1lX2RpZyAtMgogICAgPT0KICAgIGFzc2VydAogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgaXR4bl9iZWdpbgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAidW51c2VkKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYWxnbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ibG9ja2VkX2FsZ28gZXhpc3RzCiAgICBzd2FwCiAgICBidG9pCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnRfYm9hcmQuY29udHJhY3QuQ2VydEJvYXJkLl9faW5pdF9fKCkgLT4gdm9pZDoKX19pbml0X186CiAgICBwcm90byAwIDAKICAgIGJ5dGUgInBsYV9tYW5hZ2VyIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAiZXhwZWN0ZWRfY29uc2Vuc3VzX3JhdGUiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgImNlcnRpZmljYXRlX2ZlZSIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3RyZXNzX3Rlc3RfZmVlX3JvdW5kIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJwYXltZW50X2Fzc2V0IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJtYXhfdGVzdF9kdXJhdGlvbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAibWF4X3Rlc3RfYmxvY2tpbmciCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YWtlX21pbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYnl0ZSAic3Rha2VfbWF4IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBieXRlICJibG9ja2VkX2FsZ28iCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGJ5dGUgInN0YXRlIgogICAgYnl0ZSAweDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydF9ib2FyZC5jb250cmFjdC5DZXJ0Qm9hcmQuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIGludCAxCiAgICByZXR1cm4K"
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 9
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "schema": {
    "global": {
      "declared": {
        "blocked_algo": {
          "type": "uint64",
          "key": "blocked_algo"
        },
        "certificate_fee": {
          "type": "uint64",
          "key": "certificate_fee"
        },
        "expected_consensus_rate": {
          "type": "uint64",
          "key": "expected_consensus_rate"
        },
        "max_test_blocking": {
          "type": "uint64",
          "key": "max_test_blocking"
        },
        "max_test_duration": {
          "type": "uint64",
          "key": "max_test_duration"
        },
        "payment_asset": {
          "type": "uint64",
          "key": "payment_asset"
        },
        "pla_manager": {
          "type": "bytes",
          "key": "pla_manager"
        },
        "stake_max": {
          "type": "uint64",
          "key": "stake_max"
        },
        "stake_min": {
          "type": "uint64",
          "key": "stake_min"
        },
        "state": {
          "type": "bytes",
          "key": "state"
        },
        "stress_test_fee_round": {
          "type": "uint64",
          "key": "stress_test_fee_round"
        }
      },
      "reserved": {}
    },
    "local": {
      "declared": {},
      "reserved": {}
    }
  },
  "contract": {
    "name": "CertBoard",
    "desc": "\n    Certification Board servers as decentralized registrar for certificates to build trust in\n    the node running capabilities of an entity.\n    It supports issuing of attestations according to applicable node running standards by any entity.\n    Moreover, it supports generation of on-chain produced proofs of an entity's node running\n    capabilities through self-initiated stress tests, which get recorded as another certificate type.\n\n    Global state\n    ------------\n\n    pla_manager : Account\n        Platform manager account.\n\n    expected_consensus_rate : UInt64\n        Expected consensus reward rate.\n        Expressed as percentage per year.\n\n    certificate_fee : UInt64\n        Fee charged by the platform for issuing of a certificate by anyone.\n        Note: MBR increase is paid separately.\n    stress_test_fee_round : UInt64\n        Amount charged per round of the stress test.\n    payment_asset : UInt64\n        Payment method for the stress test and certificate fee.\n\n    max_test_duration : UInt64\n        Maximum allowed duration for a stress test.\n    max_test_blocking : UInt64\n        Maximum amount of rounds allowed to reserve for a stress test.\n\n    stake_min : UInt64\n        Minimum stake allowed to be used for a stress test.\n    stake_max : UInt64\n        Maximum stake allowed to be used for a stress test.\n\n    blocked_algo: UInt64\n        Amount of ALGO currently blocked and awaiting to be used in started stress test(s) requests.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            DEPLOYED - CertBoard has been created.\n            LIVE - CertBoard is live.\n\n    Methods\n    -------\n    cert_board_deploy(\n    ) -> arc4.UInt64:\n        Creates a new CertBoard.\n\n    cert_board_key_reg(\n        key_reg_info: KeyRegTxnInfo,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Issues a key (de)registration transaction by the platform.\n\n    cert_board_set(\n        pla_manager: arc4.Address,\n        expected_consensus_rate: UInt64,\n        certificate_fee: UInt64,\n        stress_test_fee_round: UInt64,\n        payment_asset: UInt64,\n        max_test_duration: UInt64,\n        max_test_blocking: UInt64,\n        stake_min: UInt64,\n        stake_max: UInt64,\n    ) -> None:\n        Sets platform parameters (anew).\n\n    cert_board_optin_asa(\n        asa: Asset,\n        sender: Account,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Opts the platform address in to an ASA.\n\n    cert_board_withdraw(\n        amount: UInt64,\n        asset_id: UInt64,\n    ) -> None:\n        Platform owner withdraws amount of asset from the platform.\n\n    cert_create(\n        recipient: arc4.Address,\n        info: CertInfo,\n        mbr_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> None:\n        An issuer creates a certificate stored on the platform.\n\n    cert_get(\n        recipient: arc4.Address,\n        issuer: arc4.Address,\n    ) -> CertInfo:\n        Returns the certificate issued by issuer to the recipient.\n\n    stress_create(\n        stake: UInt64,\n        duration: UInt64,\n        round_end_max: UInt64,\n        algo_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> arc4.UInt64:\n        Creates a stress test.\n\n    stress_end(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Ends a stress test.\n\n    stress_get(\n        recipient: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> StressTestInfo:\n        Gets information about a successfully finished stress test.\n\n    stress_record(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Records a produced block of during the stress test.\n\n    stress_start(\n        stress_test_id: UInt64,\n        key_reg_info: KeyRegTxnInfo,\n    ) -> None:\n        Starts a created test.\n\n    stress_unused(\n        user_address: arc4.Address,\n        stress_test_id: UInt64,\n    ) -> None:\n        Ends a not used stress test.\n\n    ",
    "methods": [
      {
        "name": "cert_board_deploy",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "uint64",
          "desc": "App ID of the created application."
        },
        "desc": "Creates a new CertBoard."
      },
      {
        "name": "cert_board_key_reg",
        "args": [
          {
            "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
            "name": "key_reg_info",
            "desc": "Key registration information to send."
          },
          {
            "type": "pay",
            "name": "txn",
            "desc": "Payment transaction to cover costs for the key (de)registration fee."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Issues a key (de)registration transaction by the platform."
      },
      {
        "name": "cert_board_set",
        "args": [
          {
            "type": "address",
            "name": "pla_manager",
            "desc": "Platform manager account."
          },
          {
            "type": "uint64",
            "name": "expected_consensus_rate",
            "desc": "Expected consensus reward rate. Expressed as percentage per year."
          },
          {
            "type": "uint64",
            "name": "certificate_fee",
            "desc": "Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately."
          },
          {
            "type": "uint64",
            "name": "stress_test_fee_round",
            "desc": "Amount charged per round of the stress test."
          },
          {
            "type": "uint64",
            "name": "payment_asset",
            "desc": "Payment method for the stress test and certificate fee."
          },
          {
            "type": "uint64",
            "name": "max_test_duration",
            "desc": "Maximum allowed duration for a stress test."
          },
          {
            "type": "uint64",
            "name": "max_test_blocking",
            "desc": "Maximum amount of rounds allowed to reserve for a stress test."
          },
          {
            "type": "uint64",
            "name": "stake_min",
            "desc": "Minimum stake allowed to be used for a stress test."
          },
          {
            "type": "uint64",
            "name": "stake_max",
            "desc": "Maximum stake allowed to be used for a stress test."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Sets platform parameters (anew)."
      },
      {
        "name": "cert_board_optin_asa",
        "args": [
          {
            "type": "asset",
            "name": "asa",
            "desc": "Asset to opt into."
          },
          {
            "type": "account",
            "name": "sender",
            "desc": "Account to opt into the asa."
          },
          {
            "type": "pay",
            "name": "txn",
            "desc": "Payment transaction to cover MBR increase."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Opts the platform address in to an ASA."
      },
      {
        "name": "cert_board_withdraw",
        "args": [
          {
            "type": "uint64",
            "name": "amount",
            "desc": "Amount to withdraw from the platform."
          },
          {
            "type": "uint64",
            "name": "asset_id",
            "desc": "ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Platform owner withdraws amount of asset from the platform."
      },
      {
        "name": "cert_create",
        "args": [
          {
            "type": "address",
            "name": "recipient",
            "desc": "Recipient of the certificate."
          },
          {
            "type": "byte[1024]",
            "name": "info",
            "desc": "Information to be recorded in the certificate."
          },
          {
            "type": "pay",
            "name": "mbr_txn",
            "desc": "Payment transaction for the payment of the increase of platform MBR due to creation of the certificate."
          },
          {
            "type": "txn",
            "name": "txn",
            "desc": "Transaction for the payment of the certificate issuance fee."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "An issuer creates a certificate stored on the platform."
      },
      {
        "name": "cert_get",
        "args": [
          {
            "type": "address",
            "name": "recipient",
            "desc": "Recipient of the certificate."
          },
          {
            "type": "address",
            "name": "issuer",
            "desc": "Issuer of the certificate."
          }
        ],
        "readonly": true,
        "returns": {
          "type": "byte[1024]"
        },
        "desc": "Returns the certificate issued by issuer to the recipient."
      },
      {
        "name": "stress_create",
        "args": [
          {
            "type": "uint64",
            "name": "stake",
            "desc": "Amount of stake used in the stress test. The value is expressed in microALGO."
          },
          {
            "type": "uint64",
            "name": "duration",
            "desc": "Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing."
          },
          {
            "type": "uint64",
            "name": "duration_max",
            "desc": "Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created."
          },
          {
            "type": "pay",
            "name": "algo_txn",
            "desc": "Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test."
          },
          {
            "type": "txn",
            "name": "txn",
            "desc": "Transaction for the payment of the stress test fee."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "uint64"
        },
        "desc": "Creates a stress test."
      },
      {
        "name": "stress_end",
        "args": [
          {
            "type": "address",
            "name": "user_address",
            "desc": "Address of the user that initiated the stress test."
          },
          {
            "type": "uint64",
            "name": "stress_test_id",
            "desc": "App ID of the stress test to end."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Ends a stress test."
      },
      {
        "name": "stress_get",
        "args": [
          {
            "type": "address",
            "name": "recipient",
            "desc": "Recipient of the certificate."
          },
          {
            "type": "uint64",
            "name": "stress_test_id",
            "desc": "App ID of the stress test to end."
          }
        ],
        "readonly": true,
        "returns": {
          "type": "(uint64,uint64,uint64,uint64,uint64)"
        },
        "desc": "Gets information about a successfully finished stress test."
      },
      {
        "name": "stress_record",
        "args": [
          {
            "type": "address",
            "name": "user_address",
            "desc": "Address of the user that initiated the stress test."
          },
          {
            "type": "uint64",
            "name": "stress_test_id",
            "desc": "App ID of the stress test to end."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Records a produced block of during the stress test."
      },
      {
        "name": "stress_start",
        "args": [
          {
            "type": "uint64",
            "name": "stress_test_id",
            "desc": "App ID of the stress test to end."
          },
          {
            "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
            "name": "key_reg_info"
          },
          {
            "type": "pay",
            "name": "mbr_txn",
            "desc": "Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Starts a created test."
      },
      {
        "name": "stress_unused",
        "args": [
          {
            "type": "address",
            "name": "user_address",
            "desc": "Address of the user that initiated the stress test."
          },
          {
            "type": "uint64",
            "name": "stress_test_id",
            "desc": "App ID of the stress test to end."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Ends a not used stress test."
      }
    ],
    "networks": {}
  },
  "bare_call_config": {}
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the CertBoard smart contract.
 */
export type CertBoard = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'cert_board_deploy()uint64' | 'cert_board_deploy', {
      argsObj: {
      }
      argsTuple: []
      /**
       * App ID of the created application.
       */
      returns: bigint
    }>
    & Record<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void' | 'cert_board_key_reg', {
      argsObj: {
        /**
         * Key registration information to send.
         */
        keyRegInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]
        /**
         * Payment transaction to cover costs for the key (de)registration fee.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [keyRegInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string], txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void' | 'cert_board_set', {
      argsObj: {
        /**
         * Platform manager account.
         */
        plaManager: string
        /**
         * Expected consensus reward rate. Expressed as percentage per year.
         */
        expectedConsensusRate: bigint | number
        /**
         * Fee charged by the platform for issuing of a certificate by anyone. Note: MBR increase is paid separately.
         */
        certificateFee: bigint | number
        /**
         * Amount charged per round of the stress test.
         */
        stressTestFeeRound: bigint | number
        /**
         * Payment method for the stress test and certificate fee.
         */
        paymentAsset: bigint | number
        /**
         * Maximum allowed duration for a stress test.
         */
        maxTestDuration: bigint | number
        /**
         * Maximum amount of rounds allowed to reserve for a stress test.
         */
        maxTestBlocking: bigint | number
        /**
         * Minimum stake allowed to be used for a stress test.
         */
        stakeMin: bigint | number
        /**
         * Maximum stake allowed to be used for a stress test.
         */
        stakeMax: bigint | number
      }
      argsTuple: [plaManager: string, expectedConsensusRate: bigint | number, certificateFee: bigint | number, stressTestFeeRound: bigint | number, paymentAsset: bigint | number, maxTestDuration: bigint | number, maxTestBlocking: bigint | number, stakeMin: bigint | number, stakeMax: bigint | number]
      returns: void
    }>
    & Record<'cert_board_optin_asa(asset,account,pay)void' | 'cert_board_optin_asa', {
      argsObj: {
        /**
         * Asset to opt into.
         */
        asa: number | bigint
        /**
         * Account to opt into the asa.
         */
        sender: string | Uint8Array
        /**
         * Payment transaction to cover MBR increase.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [asa: number | bigint, sender: string | Uint8Array, txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'cert_board_withdraw(uint64,uint64)void' | 'cert_board_withdraw', {
      argsObj: {
        /**
         * Amount to withdraw from the platform.
         */
        amount: bigint | number
        /**
         * ID of the asset to withdraw, i.e. ASA ID or 0 for ALGO.
         */
        assetId: bigint | number
      }
      argsTuple: [amount: bigint | number, assetId: bigint | number]
      returns: void
    }>
    & Record<'cert_create(address,byte[1024],pay,txn)void' | 'cert_create', {
      argsObj: {
        /**
         * Recipient of the certificate.
         */
        recipient: string
        /**
         * Information to be recorded in the certificate.
         */
        info: Uint8Array
        /**
         * Payment transaction for the payment of the increase of platform MBR due to creation of the certificate.
         */
        mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transaction for the payment of the certificate issuance fee.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [recipient: string, info: Uint8Array, mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'cert_get(address,address)byte[1024]' | 'cert_get', {
      argsObj: {
        /**
         * Recipient of the certificate.
         */
        recipient: string
        /**
         * Issuer of the certificate.
         */
        issuer: string
      }
      argsTuple: [recipient: string, issuer: string]
      returns: Uint8Array
    }>
    & Record<'stress_create(uint64,uint64,uint64,pay,txn)uint64' | 'stress_create', {
      argsObj: {
        /**
         * Amount of stake used in the stress test. The value is expressed in microALGO.
         */
        stake: bigint | number
        /**
         * Number of rounds for the stress test. The actual duration of the block recording is 320 rounds shorter due to consensus trailing.
         */
        duration: bigint | number
        /**
         * Maximum number of rounds allocated for the test, i.e. blocking of funds. This is to take into account key generation time after the stress testing contract has been created.
         */
        durationMax: bigint | number
        /**
         * Payment transaction for the payment of: 1) the increase of platform MBR due to creation of the stress test, 2) the fee for making the stress test contract opt-in to rewards with later key reg, and 3) the fee charged for the potential loss of platforms consensus rewards due to the stress test.
         */
        algoTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transaction for the payment of the stress test fee.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [stake: bigint | number, duration: bigint | number, durationMax: bigint | number, algoTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: bigint
    }>
    & Record<'stress_end(address,uint64)void' | 'stress_end', {
      argsObj: {
        /**
         * Address of the user that initiated the stress test.
         */
        userAddress: string
        /**
         * App ID of the stress test to end.
         */
        stressTestId: bigint | number
      }
      argsTuple: [userAddress: string, stressTestId: bigint | number]
      returns: void
    }>
    & Record<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)' | 'stress_get', {
      argsObj: {
        /**
         * Recipient of the certificate.
         */
        recipient: string
        /**
         * App ID of the stress test to end.
         */
        stressTestId: bigint | number
      }
      argsTuple: [recipient: string, stressTestId: bigint | number]
      returns: StressTestInfo
    }>
    & Record<'stress_record(address,uint64)void' | 'stress_record', {
      argsObj: {
        /**
         * Address of the user that initiated the stress test.
         */
        userAddress: string
        /**
         * App ID of the stress test to end.
         */
        stressTestId: bigint | number
      }
      argsTuple: [userAddress: string, stressTestId: bigint | number]
      returns: void
    }>
    & Record<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void' | 'stress_start', {
      argsObj: {
        /**
         * App ID of the stress test to end.
         */
        stressTestId: bigint | number
        keyRegInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]
        /**
         * Payment transaction for the payment of the increase of platform MBR due to creation of the box to record the stress test.
         */
        mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [stressTestId: bigint | number, keyRegInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string], mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'stress_unused(address,uint64)void' | 'stress_unused', {
      argsObj: {
        /**
         * Address of the user that initiated the stress test.
         */
        userAddress: string
        /**
         * App ID of the stress test to end.
         */
        stressTestId: bigint | number
      }
      argsTuple: [userAddress: string, stressTestId: bigint | number]
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      blockedAlgo?: IntegerState
      certificateFee?: IntegerState
      expectedConsensusRate?: IntegerState
      maxTestBlocking?: IntegerState
      maxTestDuration?: IntegerState
      paymentAsset?: IntegerState
      plaManager?: BinaryState
      stakeMax?: IntegerState
      stakeMin?: IntegerState
      state?: BinaryState
      stressTestFeeRound?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type CertBoardSig = keyof CertBoard['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends CertBoardSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Represents a KeyRegTxnInfo result as a struct
 */
export type KeyRegTxnInfo = {
  voteFirst: bigint
  voteLast: bigint
  voteKeyDilution: bigint
  votePk: Uint8Array
  selectionPk: Uint8Array
  stateProofPk: Uint8Array
  sender: string
}
/**
 * Converts the tuple representation of a KeyRegTxnInfo to the struct representation
 */
export function KeyRegTxnInfo([voteFirst, voteLast, voteKeyDilution, votePk, selectionPk, stateProofPk, sender]: [bigint, bigint, bigint, Uint8Array, Uint8Array, Uint8Array, string] ) {
  return {
    voteFirst,
    voteLast,
    voteKeyDilution,
    votePk,
    selectionPk,
    stateProofPk,
    sender,
  }
}
/**
 * Represents a StressTestInfo result as a struct
 */
export type StressTestInfo = {
  avrOnlineStake: bigint
  cntProducedBlock: bigint
  roundStart: bigint
  roundEnd: bigint
  stake: bigint
}
/**
 * Converts the tuple representation of a StressTestInfo to the struct representation
 */
export function StressTestInfo([avrOnlineStake, cntProducedBlock, roundStart, roundEnd, stake]: [bigint, bigint, bigint, bigint, bigint] ) {
  return {
    avrOnlineStake,
    cntProducedBlock,
    roundStart,
    roundEnd,
    stake,
  }
}
/**
 * Maps a method signature from the CertBoard smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends CertBoardSig> = CertBoard['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the CertBoard smart contract to the method's return type
 */
export type MethodReturn<TSignature extends CertBoardSig> = CertBoard['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type CertBoardCreateCalls = (typeof CertBoardCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type CertBoardCreateCallParams =
  | (TypedCallParams<'cert_board_deploy()uint64'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type CertBoardDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: CertBoardCreateCalls) => CertBoardCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class CertBoardCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the CertBoard smart contract using the cert_board_deploy()uint64 ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      certBoardDeploy(args: MethodArgs<'cert_board_deploy()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'cert_board_deploy()uint64' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method
   *
   * Issues a key (de)registration transaction by the platform.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certBoardKeyReg(args: MethodArgs<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.keyRegInfo, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method
   *
   * Sets platform parameters (anew).
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certBoardSet(args: MethodArgs<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.plaManager, args.expectedConsensusRate, args.certificateFee, args.stressTestFeeRound, args.paymentAsset, args.maxTestDuration, args.maxTestBlocking, args.stakeMin, args.stakeMax],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the cert_board_optin_asa(asset,account,pay)void ABI method
   *
   * Opts the platform address in to an ASA.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certBoardOptinAsa(args: MethodArgs<'cert_board_optin_asa(asset,account,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_board_optin_asa(asset,account,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.asa, args.sender, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the cert_board_withdraw(uint64,uint64)void ABI method
   *
   * Platform owner withdraws amount of asset from the platform.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certBoardWithdraw(args: MethodArgs<'cert_board_withdraw(uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_board_withdraw(uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.amount, args.assetId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the cert_create(address,byte[1024],pay,txn)void ABI method
   *
   * An issuer creates a certificate stored on the platform.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certCreate(args: MethodArgs<'cert_create(address,byte[1024],pay,txn)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_create(address,byte[1024],pay,txn)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.recipient, args.info, args.mbrTxn, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the cert_get(address,address)byte[1024] ABI method
   *
   * Returns the certificate issued by issuer to the recipient.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static certGet(args: MethodArgs<'cert_get(address,address)byte[1024]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'cert_get(address,address)byte[1024]' as const,
      methodArgs: Array.isArray(args) ? args : [args.recipient, args.issuer],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_create(uint64,uint64,uint64,pay,txn)uint64 ABI method
   *
   * Creates a stress test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressCreate(args: MethodArgs<'stress_create(uint64,uint64,uint64,pay,txn)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_create(uint64,uint64,uint64,pay,txn)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.stake, args.duration, args.durationMax, args.algoTxn, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_end(address,uint64)void ABI method
   *
   * Ends a stress test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressEnd(args: MethodArgs<'stress_end(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_end(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.userAddress, args.stressTestId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Gets information about a successfully finished stress test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressGet(args: MethodArgs<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.recipient, args.stressTestId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_record(address,uint64)void ABI method
   *
   * Records a produced block of during the stress test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressRecord(args: MethodArgs<'stress_record(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_record(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.userAddress, args.stressTestId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method
   *
   * Starts a created test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressStart(args: MethodArgs<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.stressTestId, args.keyRegInfo, args.mbrTxn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stress_unused(address,uint64)void ABI method
   *
   * Ends a not used stress test.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stressUnused(args: MethodArgs<'stress_unused(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stress_unused(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.userAddress, args.stressTestId],
      ...params,
    }
  }
}

/**
 * A client to make calls to the CertBoard smart contract
 */
export class CertBoardClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `CertBoardClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof CertBoard['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the CertBoard smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: CertBoardDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(CertBoardCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the CertBoard smart contract using the cert_board_deploy()uint64 ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result: App ID of the created application.
       */
      async certBoardDeploy(args: MethodArgs<'cert_board_deploy()uint64'>, params: AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'cert_board_deploy()uint64'>, AppCreateCallTransactionResult>(await $this.appClient.create(CertBoardCallFactory.create.certBoardDeploy(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the CertBoard smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method.
   *
   * Issues a key (de)registration transaction by the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certBoardKeyReg(args: MethodArgs<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certBoardKeyReg(args, params))
  }

  /**
   * Calls the cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method.
   *
   * Sets platform parameters (anew).
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certBoardSet(args: MethodArgs<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certBoardSet(args, params))
  }

  /**
   * Calls the cert_board_optin_asa(asset,account,pay)void ABI method.
   *
   * Opts the platform address in to an ASA.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certBoardOptinAsa(args: MethodArgs<'cert_board_optin_asa(asset,account,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certBoardOptinAsa(args, params))
  }

  /**
   * Calls the cert_board_withdraw(uint64,uint64)void ABI method.
   *
   * Platform owner withdraws amount of asset from the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certBoardWithdraw(args: MethodArgs<'cert_board_withdraw(uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certBoardWithdraw(args, params))
  }

  /**
   * Calls the cert_create(address,byte[1024],pay,txn)void ABI method.
   *
   * An issuer creates a certificate stored on the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certCreate(args: MethodArgs<'cert_create(address,byte[1024],pay,txn)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certCreate(args, params))
  }

  /**
   * Calls the cert_get(address,address)byte[1024] ABI method.
   *
   * Returns the certificate issued by issuer to the recipient.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public certGet(args: MethodArgs<'cert_get(address,address)byte[1024]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.certGet(args, params))
  }

  /**
   * Calls the stress_create(uint64,uint64,uint64,pay,txn)uint64 ABI method.
   *
   * Creates a stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressCreate(args: MethodArgs<'stress_create(uint64,uint64,uint64,pay,txn)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressCreate(args, params))
  }

  /**
   * Calls the stress_end(address,uint64)void ABI method.
   *
   * Ends a stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressEnd(args: MethodArgs<'stress_end(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressEnd(args, params))
  }

  /**
   * Calls the stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Gets information about a successfully finished stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressGet(args: MethodArgs<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressGet(args, params), StressTestInfo)
  }

  /**
   * Calls the stress_record(address,uint64)void ABI method.
   *
   * Records a produced block of during the stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressRecord(args: MethodArgs<'stress_record(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressRecord(args, params))
  }

  /**
   * Calls the stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method.
   *
   * Starts a created test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressStart(args: MethodArgs<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressStart(args, params))
  }

  /**
   * Calls the stress_unused(address,uint64)void ABI method.
   *
   * Ends a not used stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stressUnused(args: MethodArgs<'stress_unused(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(CertBoardCallFactory.stressUnused(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<CertBoard['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get blockedAlgo() {
        return CertBoardClient.getIntegerState(state, 'blocked_algo')
      },
      get certificateFee() {
        return CertBoardClient.getIntegerState(state, 'certificate_fee')
      },
      get expectedConsensusRate() {
        return CertBoardClient.getIntegerState(state, 'expected_consensus_rate')
      },
      get maxTestBlocking() {
        return CertBoardClient.getIntegerState(state, 'max_test_blocking')
      },
      get maxTestDuration() {
        return CertBoardClient.getIntegerState(state, 'max_test_duration')
      },
      get paymentAsset() {
        return CertBoardClient.getIntegerState(state, 'payment_asset')
      },
      get plaManager() {
        return CertBoardClient.getBinaryState(state, 'pla_manager')
      },
      get stakeMax() {
        return CertBoardClient.getIntegerState(state, 'stake_max')
      },
      get stakeMin() {
        return CertBoardClient.getIntegerState(state, 'stake_min')
      },
      get state() {
        return CertBoardClient.getBinaryState(state, 'state')
      },
      get stressTestFeeRound() {
        return CertBoardClient.getIntegerState(state, 'stress_test_fee_round')
      },
    }
  }

  public compose(): CertBoardComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      certBoardKeyReg(args: MethodArgs<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certBoardKeyReg(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      certBoardSet(args: MethodArgs<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certBoardSet(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      certBoardOptinAsa(args: MethodArgs<'cert_board_optin_asa(asset,account,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certBoardOptinAsa(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      certBoardWithdraw(args: MethodArgs<'cert_board_withdraw(uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certBoardWithdraw(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      certCreate(args: MethodArgs<'cert_create(address,byte[1024],pay,txn)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certCreate(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      certGet(args: MethodArgs<'cert_get(address,address)byte[1024]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.certGet(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stressCreate(args: MethodArgs<'stress_create(uint64,uint64,uint64,pay,txn)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressCreate(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stressEnd(args: MethodArgs<'stress_end(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressEnd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stressGet(args: MethodArgs<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressGet(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(StressTestInfo)
        return this
      },
      stressRecord(args: MethodArgs<'stress_record(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressRecord(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stressStart(args: MethodArgs<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressStart(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stressUnused(args: MethodArgs<'stress_unused(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stressUnused(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as CertBoardComposer
  }
}
export type CertBoardComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method.
   *
   * Issues a key (de)registration transaction by the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certBoardKeyReg(args: MethodArgs<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_board_key_reg((uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>]>

  /**
   * Calls the cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method.
   *
   * Sets platform parameters (anew).
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certBoardSet(args: MethodArgs<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_board_set(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void'>]>

  /**
   * Calls the cert_board_optin_asa(asset,account,pay)void ABI method.
   *
   * Opts the platform address in to an ASA.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certBoardOptinAsa(args: MethodArgs<'cert_board_optin_asa(asset,account,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_board_optin_asa(asset,account,pay)void'>]>

  /**
   * Calls the cert_board_withdraw(uint64,uint64)void ABI method.
   *
   * Platform owner withdraws amount of asset from the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certBoardWithdraw(args: MethodArgs<'cert_board_withdraw(uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_board_withdraw(uint64,uint64)void'>]>

  /**
   * Calls the cert_create(address,byte[1024],pay,txn)void ABI method.
   *
   * An issuer creates a certificate stored on the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certCreate(args: MethodArgs<'cert_create(address,byte[1024],pay,txn)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_create(address,byte[1024],pay,txn)void'>]>

  /**
   * Calls the cert_get(address,address)byte[1024] ABI method.
   *
   * Returns the certificate issued by issuer to the recipient.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  certGet(args: MethodArgs<'cert_get(address,address)byte[1024]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'cert_get(address,address)byte[1024]'>]>

  /**
   * Calls the stress_create(uint64,uint64,uint64,pay,txn)uint64 ABI method.
   *
   * Creates a stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressCreate(args: MethodArgs<'stress_create(uint64,uint64,uint64,pay,txn)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_create(uint64,uint64,uint64,pay,txn)uint64'>]>

  /**
   * Calls the stress_end(address,uint64)void ABI method.
   *
   * Ends a stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressEnd(args: MethodArgs<'stress_end(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_end(address,uint64)void'>]>

  /**
   * Calls the stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Gets information about a successfully finished stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressGet(args: MethodArgs<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_get(address,uint64)(uint64,uint64,uint64,uint64,uint64)'>]>

  /**
   * Calls the stress_record(address,uint64)void ABI method.
   *
   * Records a produced block of during the stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressRecord(args: MethodArgs<'stress_record(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_record(address,uint64)void'>]>

  /**
   * Calls the stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void ABI method.
   *
   * Starts a created test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressStart(args: MethodArgs<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_start(uint64,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address),pay)void'>]>

  /**
   * Calls the stress_unused(address,uint64)void ABI method.
   *
   * Ends a not used stress test.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stressUnused(args: MethodArgs<'stress_unused(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, MethodReturn<'stress_unused(address,uint64)void'>]>

  /**
   * Makes a clear_state call to an existing instance of the CertBoard smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): CertBoardComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): CertBoardComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<CertBoardComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<CertBoardComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type CertBoardComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type CertBoardComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
